
Docker es una plataforma que permite empaquetar aplicaciones y sus dependencias en contenedores, que son entornos ligeros, portátiles y aislados.
Estos contenedores aseguran que las aplicaciones se ejecuten de manera consistente en cualquier entorno,
ya sea en desarrollo, pruebas o producción, eliminando problemas de compatibilidad entre sistemas.



Instalacion y configuración de Docker:

Empezamos utilizando la siguiente comanda para asegurarnos de que todo esté bien actualizado y no dé problemas:
    -sudo apt update && sudo apt upgrade


  -sudo apt-get install ca-certificates curl

  -sudo install -m 0755 -d /etc/apt/keyrings

  -sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc

  -sudo chmod a+r /etc/apt/keyrings/docker.asc



# Add the repository to Apt sources:

echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

Hasta el /dev/null se copia

sudo apt-get update



INSTALAR LA ÚLTIMA VERSIÓN

sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin



COMPROBAR ESTADO DOCKER

sudo systemctl status docker

docker --version



AÑADIR USUARIO administrador A GRUPO DOCKER

sudo usermod -aG docker administrador

su - administrador



COMPROBAR USUARIOS GRUPO DOCKER

id -nG



VER SUBCOMANDOS

docker



DESCARGAR IMAGEN ej:HELLO-WORLD

docker run hello-world #Instala y lo ejecuta



BUSCAR IMAGEN UBUNTU EN DOCKERHUB

docker search ubuntu



DESCARGAR IMAGEN UBUNTU

docker pull ubuntu #Descarga solo el contenido



VER IMAGENES DOCKER

docker images



EJECUTAR UN CONTENEDOR DE DOCKER

docker run -it ubuntu

apt update

exit



ADMINISTRAR CONTENEDORES DOCKER

VER CONTENEDORES ACTIVOS

docker ps



VER CONTENEDORES ACTIVOS E INACTIVOS

docker ps -a



VER ÚLTIMO CONTENEDOR CREADO

docker ps -l


VER CUANTOS CONTENEDORES TENEMOS EN TOTAL

docker ps -a | wc -l




VER LOS IDS DE LOS CONTENEDORES PARADOS


docker ps -ak



INICIAR UN CONTENEDOR

docker start IDCONTENEDOR

VER CUANTO OCUPAPAN LOS CONTENEDORES Y IMAGENES

docker system df

COPIAR FICHEROS Y METERLOS EN UN CONTENEDOR

docker cp fichero.txt contenedor1:/home

COPIAR FICHEROS DE UN CONTENEDOR A LA MAQUINA

*no hay que estar dentro del contenedor

docker cp contendedor1:/home/fichero.txt . #el "." es donde te encuentras actualmente



VER LOS CAMBIOS HECHOS EN UN CONTENEDOR

docker diff (contenedor)

A - AÑADIDO (APPEND)
C - CAMBIO (CHANGED)
D - ELIMINADO (DELETED)

La diferencia que muestra docker diff es entre el sistema de archivos actual del contenedor y el sistema de archivos original de la imagen en la que se basó.
Es decir, compara el estado actual del contenedor con el estado de la imagen al momento de crearse el contenedor.

Así, si haces cambios en el contenedor después de arrancarlo (como crear, modificar o eliminar archivos), docker diff listará esos cambios,
ya que son diferencias con respecto a la imagen base.

No compara un arranque anterior con uno posterior, sino el estado actual del contenedor contra el sistema de archivos de la imagen inicial.




CREAR TUS PODRIAS IMAGENES

cuando tenga una imagen, ejemplo ubuntu(la predeterminada), y ya tienes paquetes y servicios en ella y quieres tener otra igual puedes hacer un:

docker commit (contenedor_al_que_copiar) (como_llamar_a_la_imagen)
docker commit ubuntu1 ubuntu_mejora

te saldra como imagen incluso:

  docker images
  REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
  ubuntu_mejora latest    1e3c0825dfb3   5 seconds ago   124MB
  ubuntu        latest    59ab366372d5   3 weeks ago     78.1MB  


  docker run -it -d --name ubuntu3 ubuntu_mejora bash




DATO CURIOSO

Las imagenes de S.0 solo tienen 1 capa, se puede mirar asi:

docker image inspect (IMAGEN)

UBUNTU:
  "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:a46a5fb872b554648d9d0262f302b2c1ded46eeb1ef4dc727ecc5274605937af"
            ]
        },

una imagen de microservicio que me gusta:
DOCUSEAL:
  "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07",
                "sha256:6e3d66f7c387dd4331b32d32954ebaee7a666c103015a29a7ca5c4f01fe5d690",
                "sha256:cd7e80b727b807d777b65222e74bd9392159d02d4606bb3028137916963f1dc4",
                "sha256:6c389d3b854a6a1b02f427dfabccbd4b742494af5ee249effafc9b7078ecea53",
                "sha256:9b8dee3bb3e10e25ce31aa7c52fbca050584e7947b177017d49deb922b38b34e",
                "sha256:ea23f1f76c095298c4ffbc5a5b9b29539d3604ebaa46f0ac5da62b7e9697a85d",
                "sha256:5aa460b9a45ca01c7a9f314ef6d46367741db830c0726169e9ea6b9190aa6d58",
                "sha256:fce52c012bc5af8a40fd5451c7356587ccf501f04fd3afeecc7ad079d3730c0a",
                "sha256:b5e82aeb0cb42cd79c32006981987c035eff1e29965c0277343df336fee7e69d",
                "sha256:5fab0a737ed60b5c2d967cb3b4cc6b6e458434e8213dc265a521ac963d075f00",
                "sha256:43e78d21f2cbb4b012453d3df9b66fe9da3dc954e54ec4cac8ceef2571d26dd7",
                "sha256:419941d73ab4bb793383870e02f5837d1738916483f672f55e9f0991ca9fb9a9",
                "sha256:c09d8cac30a44e58a99eb5d989162c18bb0a9cf9354d7851827c4ca7bc98e011",
                "sha256:14b5fa5033262c0af8cded092034ecc239210b8a359f0eb5a2b5fbc10a0c843d",
                "sha256:7baf304a9d54a0f5a04a3075abbb4e47ba3bf70a25b58df3a96be074c04f0711",
                "sha256:2621cd15ce1e12c8aaecab710775e05b2847091454b7670299a0b29d67ffe6d1",
                "sha256:1af19a9e7332a588794f254f590a0431f15a09f8d2423b6c3afb822997e06e69",
                "sha256:8827586cf28360e67ed9488cd0193037e16fbd864558b6877b79cdcfdf543928",
                "sha256:0587a5bd0ad7dda1f7512e5e6ea15f63e2c4298f74c143626ef9fb1401476e00",
                "sha256:4462b2190d4e6d835374bda6c3fe7af83f74a1d8044c9571b74b35b0fe2d14a0",
                "sha256:29c70a551074c9c9be8d521821f9e51edbc5fcefbde1b1b76a9af77311fbdd13",
                "sha256:6ba0a212b79ef6a3b1eb9490759640868fb3d8d7848a4c99e41e9edf3ed8ad77",
                "sha256:a95fca15ee49d09b7789808c81b6de80966e1c6f154d2971179c172ea94c222e",
                "sha256:e7bd3c9dfa69097c66e9153a82ef73f114c35a7f15b97a0390b56d7dddf01921",
                "sha256:7dcce2938571678a79f38d7253487214a216e912c42a21586b6b0f83eef891f1"
            ]
        },          


Se van creado mas capas a medida que tu escribas en ellas




TAG
*El comando docker tag se usa para crear un alias (o etiqueta) para una imagen existente. Esto es útil para organizar imágenes o prepararlas para subirlas a un registro, como Docker Hub.

docker images     
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       latest    278628f08d49   5 weeks ago   117MB
docker tag ubuntu miubuntu
docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
miubuntu     latest    278628f08d49   5 weeks ago   117MB
ubuntu       latest    278628f08d49   5 weeks ago   117MB

Apuntan al mismo id





COMPRIMIR IMAGENES EN .tar

  -docker image save imagen -o(output) nombreimagen.tar

Ejemplo

  -docker image save ubuntu -o ubuntucomprimido.tar

Y lo creara donde te situes

Vamos a hacer una prueba:

docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       latest    278628f08d49   5 weeks ago   117MB
docker rmi ubuntu                
Untagged: ubuntu:latest
Deleted: sha256:278628f08d4979fb9af9ead44277dbc9c92c2465922310916ad0c46ec9999295
docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE

Ya no tengo la imagen de ubuntu pero si tengo el ubuntucomprimido.tar


DESCOMPRIMIR IMAGENES EN .tar

  --docker image load -i(intput) nombreimagen.tar

Ejemplo

  -docker image load -i ubuntucomprimido.tar

docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
docker image load -i ubuntucomprimido.tar
Loaded image: ubuntu:latest
docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       latest    278628f08d49   5 weeks ago   117MB




MEMORIA EN LOS CONTENEDORES

Ejemplo:

  -docker run -it --name apachesinlimite -d httpd
  -docker run -it --name apacheconlimite -d -m 12m httpd
  -docker stats

CONTAINER ID   NAME              CPU %     MEM USAGE / LIMIT    MEM %     NET I/O       BLOCK I/O   PIDS
3b5968946bfb   apacheconlimite   0.00%     10.79MiB / 12MiB     89.91%    746B / 0B     0B / 0B     82
c4fb228fbece   apachesinlimite   0.00%     24.1MiB / 7.692GiB   0.31%     1.05kB / 0B   0B / 0B     82

Vemos que que el apacheconlimite tiene el limite de 12m porque se lo posimos en "docker run -it --name apacheconlimite -d -m 12m httpd",
poreso tiene un % mas alto que el otro, aparte de ello por defecto tambien viene con swap que es una parte del disco duro que el sistema usa como memoria virtual cuando la RAM está llena.
Es más lento que la RAM porque depende del almacenamiento, pero evita que el sistema se quede sin memoria por completo.

Por defecto aprte del -m 12(limite de 12m) tambien te asigna 12m de momoria swap por si te pasas del limite establecido no detener o matar al contenedor

Por defecto, también permite usar 12 MB adicionales de swap (RAM + swap = 24 MB).

12 + 12 = 24, docker siempre te asignara Xm y te pondra Xm de memoria swap



  -docker run --name apache1 -it -d -m 256m --memory-swap 1G httpd

-m 256m:
Limita la memoria RAM del contenedor a 256 MB.

--memory-swap 1G:
Configura el límite total de memoria (RAM + swap) en 1 GB. Esto significa que:

El contenedor puede usar hasta 256 MB de RAM.
Si necesita más memoria, puede usar hasta 744 MB de swap (1 GB total - 256 MB RAM).





CPU EN LOS CONTENEDORES

  -docker run -it -d --name apache --cpus=X httpd

--cpus=X: 
Limita el contenedor a utilizar X núcleos de CPU, en lugar de los recursos predeterminados. 


*Si poneis:
  -docker info

Hos sale el numero de cpu's que teneis

Ejemplo

Yo tengo 16 cpu's y lanzo esto:

  -docker run -it -d --name apache --cpus=5 httpd

Quiere decir eso ahora que solo puedo usar 11 cpu's?, NO

Lo que estás haciendo es limitar el contenedor a utilizar solo 5 núcleos de CPU. No significa que el sistema no pueda usar los 11 núcleos restantes, ya que el límite de --cpus=5 solo se aplica al contenedor de Docker y no al host en general.
En otras palabras, con este comando:
El contenedor Apache podrá usar hasta 5 núcleos de CPU.

Y puedo usar esto sin problema:

  -docker run -it -d --name apache --cpus=15 httpd

Y no habra problema ya que el primer contenedor su limite sera 5 cpu's y el del segundo 15


PERO QUE PASA CUANDO NOS PASAMOS DE LAS CPU'S QUE TENEMOS?

  -docker run -it -d --name apache --cpus=17 httpd
docker: Error response from daemon: Range of CPUs is from 0.01 to 16.00, as there are only 16 CPUs available.
See 'docker run --help'.

Pues que sale un ERROR



CPU EN LOS CONTENEDORES 2

  -docker run --name apache1 -it -d --cpu-shares=X httpd

--cpu-shares=X  

La opción --cpu-shares=1024 asigna una prioridad relativa para el uso de la CPU al contenedor,
indicando cómo se dividirán los recursos de CPU si varios contenedores compiten por ellos.
Un valor más alto significa mayor prioridad frente a otros contenedores; por defecto,
1024 es la prioridad estándar.
No limita el uso de CPU, solo influye en la proporción de recursos asignados durante la competencia.

Que cuanto mas --cpu-shares=X pongas priorizara el acceso a la CPU si hay competencia entre varios contenedores




CONTEXTOS EN DOCKER

En Docker, los contextos son configuraciones que permiten a los usuarios administrar múltiples entornos de Docker desde una sola máquina. Esto es útil para trabajar con diferentes hosts o configuraciones de Docker, como un clúster remoto, una máquina virtual, o un entorno local. Los contextos simplifican el cambio entre estos entornos sin necesidad de configurar repetidamente las variables de conexión.

*Es decir: Con Docker Context puedes conectarte a diferentes servidores Docker(que tengan Docker instalado) para administrarlos desde tu máquina local.
Esto incluye interactuar con los contenedores,
imágenes y volúmenes que se encuentran en esos servidores.

*Basicamente lo que haces es un "ssh" a otro servidor docker donde le estas pasando los contendores, imagenes etc...



La idea es muy parecida a lo que hace SSH, pero con Docker, en lugar de acceder a una terminal remota,
lo que haces es conectarte a un servidor Docker remoto para poder ejecutar comandos de Docker allí (como si estuvieras trabajando directamente en ese servidor), pero sin necesidad de interactuar manualmente con la terminal del servidor.

Comparación con SSH:
SSH: Accedes a una terminal remota donde puedes ejecutar cualquier comando, incluida la gestión de Docker.

Docker Context: Te conectas a un servidor Docker remoto y ejecutas comandos de Docker directamente sobre ese servidor (sin necesidad de usar SSH). Es como si estuvieras gestionando Docker en esa máquina como si fuera local.


*SIMULACION

tengo un servidor ubuntu server con docker instalado con la ip 192.168.1.199 y quiero conectarme a el y uso docker-desktop


en el docker-desktop:

  -docker context create servidor-remoto --docker "host=tcp://192.168.1.199:2375(puerto que escuche docker)"

Sino funciona yo use esta:

  -docker context create docker-server --docker "host=ssh://user@ip-server"
  -docker context use docker-server
  docker-server
Current context is now "docker-server"
docker info
user@ip-server's password: user@ip-server's password:


*ACLARACION

Cuando te conectas a un servidor remoto usando un contexto de Docker (como docker context use servidor-remoto),
Docker solo te da acceso a la interfaz de Docker en ese servidor remoto.
No tienes acceso directo al sistema de archivos del servidor para ejecutar comandos como mkdir o ver un archivo Docker Compose.








DETENER CONTENEDOR

docker stop IDCONTENEDOR

DETENER TODOS LOS CONTENEDORES

docker stop $(docker ps -q)

ELIMINAR TODAS LAS IMAGENES

docker rmi -f $(docker images -q)

ELIMINAR LAS REDES QUE NO ESTAN EN USO:

docker network prune

ELIMINAR LOS PROCESOS INACTIVOS:

docker rm $(docker ps -a -f status=exited -q)

VER LA IP DE UN CONTENEDOR:

docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' [contenedor]

Crear un contenedor con un nombre

docker create --name alex mongo

Crear un contenedor y ponerle los puertos

docker create -p27018 --name alex mysql



ELIMINAR CONTENEDOR

docker rm IDCONTENEDOR





DOCKER COMPOSE

*Yo uso la version del "-", es decir que hago: "docker-compose up -d" por ejemplo, si no hos deja y hos da un erro alomejor teneis que poner "docker compose..."


Parar/Iniciar los contenedores que cuelgan de una carpeta, ejemplo:

  -docker-compose stop/start

Ese comando parar o iniciara los contenedores que cuelguen del directorio en el que estes  


LIMPIEZA TOTAL DE CONTENEDORES: DETENER, ELIMINAR TODOS LOS CONTENEDORES, REDES, VOLUMENES Y SERVICIOS

  -docker-compose down



PAUSE/UNPAUSE

  -docker-compose pause
  (pausa a todos)

  -docker pause contenedor1
  (pausa solo a ese contenedor)


RESTART

  -docker-compose restart




PROYECTO

  -docker-compose -p proyecto1 up -d

*Despues de haber creado el docker-compose.yml, en vez de levartarlo y que nos de el nombre del directorio en el que estemos podemos poner la clausula -p, que permite personalizar el nombre del proyecto, evitando que Docker Compose use el nombre del directorio por defecto como prefijo  


*Prueba

Yo estoy en: Servicios\Docker\Linux\docuseal2

cd .\Servicios\Docker\Linux\docuseal2\
Servicios\Docker\Linux\docuseal2> docker-compose -p proyecto1 up -d
[+] Running 30/2
 ✔ docuseal Pulled                                                                                                                                                                                   21.3s 
 ✔ postgres Pulled                                                                                                                                                                                   19.7s 
[+] Running 3/3
 ✔ Network proyecto1_default       Created                                                                                                                                                            0.1s 
 ✔ Container proyecto1-postgres-1  Healthy                                                                                                                                                           16.1s 
 ✔ Container docuseal              Started                                                                                                                                                           12.0s 
Servicios\Docker\Linux\docuseal2> docker-compose ps
NAME      IMAGE     COMMAND   SERVICE   CREATED   STATUS    PORTS

*Porque no nos dice los contenedores levantados?
Porque cuando haces docker-compose ps lo que busca es el nombre del directorio en el que te encuentras, para verlo tenemos que poner tambien la clausula -p


Servicios\Docker\Linux\docuseal2> docker-compose -p proyecto1 ps
NAME                   IMAGE                      COMMAND                  SERVICE    CREATED         STATUS                   PORTS
docuseal               docuseal/docuseal:latest   "/app/bin/bundle exe…"   docuseal   8 minutes ago   Up 7 minutes             0.0.0.0:3000->3000/tcp
proyecto1-postgres-1   postgres:15                "docker-entrypoint.s…"   postgres   8 minutes ago   Up 8 minutes (healthy)   5432/tcp


*Pues hacerlo desde cualquier parte:

Servicios> docker-compose -p proyecto1 ps
NAME                   IMAGE                      COMMAND                  SERVICE    CREATED          STATUS                    PORTS
docuseal               docuseal/docuseal:latest   "/app/bin/bundle exe…"   docuseal   10 minutes ago   Up 10 minutes             0.0.0.0:3000->3000/tcp
proyecto1-postgres-1   postgres:15                "docker-entrypoint.s…"   postgres   10 minutes ago   Up 10 minutes (healthy)   5432/tcp




PROFILES

*Los Profiles (perfiles) son una característica que permite gestionar diferentes configuraciones dentro de un archivo docker-compose.yml.
Los perfiles son útiles cuando tienes varios entornos (como desarrollo, pruebas y producción) y necesitas activar o desactivar servicios específicos dependiendo del entorno en el que estés trabajando.




services:
  web:
    image: my-web-app
    ports:
      - "8080:80"

  database:
    image: mysql
    profiles:
      - prod

  debugger:
    image: debug-tool
    profiles:
      - dev



Que hara?:
  -docker-compose --profile dev up -d


Lo que haces es levantar el contenedor web y el contenedor debugger

*Siempre se inician por defecto cuando ejecutas docker-compose up, independientemente de los perfiles que actives.
*En el ejemplo anterior, el servicio web no tiene un perfil asignado, así que siempre se iniciará.


*Ejemplo

docker-compose --profile dev up -d
[+] Running 14/9
 ✔ web                                                       #el web lo que coje siempre Pulled                                                                                                                                                                                        14.6s 
 ✔ debugger                                                  #al ponerle --profile dev, ha cojido el debugger que esta asocisdo a ese profile   Pulled                                                                                                                                                                                   41.8s 
[+] Running 2/3
 ✔ Network prueba_default       Created                                                                                                                                                               0.0s 
 - Container prueba-web-1       Starting                                                                                                                                                              3.0s 
 ✔ Container prueba-debugger-1  Started                                                                                                                                                               3.0s 
Error response from daemon: driver failed programming external connectivity on endpoint prueba-web-1 (9f302277fa21699e244ab029d034fc7b55ce0d5dc94c3fb282de26e7ec51ab87): Bind for 0.0.0.0:8080 failed: port is already allocated
Servicios\Docker\Linux\prueba> docker-compose down
[+] Running 2/2
 ✔ Container prueba-web-1  Removed                                                                                                                                                                    0.0s 
 ✔ Network prueba_default  Removed                                                                                                                                                                    0.2s 
Servicios\Docker\Linux\prueba> docker-compose --profile prod up -d  #al ponerle ahora el prod, solo cojera el mysql y la web
[+] Running 11/11
 ✔ database              Pulled                                                                                                                                                                                    22.6s 
   ✔ 1f87d67b89c6 Download complete                                                                                                                                                                   0.4s 
   ✔ a841bff36f3c Download complete                                                                                                                                                                   2.9s 
   ✔ cd0d5df9937b Download complete                                                                                                                                                                  13.1s 
   ✔ cb5a6a8519b2 Download complete                                                                                                                                                                   0.6s 
   ✔ 570d30cf82c5 Download complete                                                                                                                                                                   0.4s 
   ✔ 5e49e1f26961 Download complete                                                                                                                                                                   0.5s 
   ✔ 80ba30c57782 Download complete                                                                                                                                                                   0.5s 
   ✔ 2c0a233485c3 Download complete                                                                                                                                                                  15.5s 
   ✔ 0b9dc7ad7f03 Download complete                                                                                                                                                                   0.6s 
   ✔ ced670fc7f1c Download complete                                                                                                                                                                  14.9s 
[+] Running 2/3
 ✔ Network prueba_default       Created                                                                                                                                                               0.0s 
 - Container prueba-web-1       Starting                                                                                                                                                              3.1s 
 ✔ Container prueba-database-1  Started                                                                                                                                                               3.1s 
Error response from daemon: driver failed programming external connectivity on endpoint prueba-web-1 (2a0b601339d35e463c99d9e3ed6cf387bd0ea526bf7f6b03d0297aa46b1b4ed7): Bind for 0.0.0.0:8080 failed: port is already allocated
Servicios\Docker\Linux\prueba> docker-compose --profile dev/prod down


CPU/MEORIA


services:
  app:
    image: node:18
    memory: 256M            # Reserva al menos 256 MB de memoria
    cpus: "0.25"            # Reserva al menos 25% de un solo núcleo de CPU
    cpu_count: 1            # Le da acceso a 1 núcleo de CPU
    cpu_shares: 512         # Le asigna una prioridad media de uso de CPU
    mem_limit: 50m          # Limita el contenedor a usar máximo 50 MB de memoria