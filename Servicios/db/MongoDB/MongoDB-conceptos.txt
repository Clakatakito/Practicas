

MongoDB es un sistema de bases de datos NoSQL que almacena datos en un formato similar a JSON llamado BSON (Binary JSON). Es conocido por ser escalable, flexible y adecuado para manejar grandes volúmenes de datos no estructurados o semi-estructurados.


MODELO DE DATOS:

SQL: Usa un modelo relacional, donde los datos se organizan en tablas con filas y columnas. Las relaciones entre las tablas se definen mediante claves primarias y foráneas.
NoSQL: Utiliza modelos más flexibles, como documentos (por ejemplo, en MongoDB), clave-valor, grafos o columnas. No es necesario definir un esquema rígido, lo que permite una mayor flexibilidad.

2. Estructura de datos:
SQL: Los datos deben seguir una estructura predefinida, es decir, el tipo de cada campo debe definirse al crear la base de datos.
NoSQL: Los datos no tienen una estructura fija. Pueden ser documentos JSON, valores clave, o datos organizados de manera libre.

3. Escalabilidad:
SQL: Escala principalmente de forma vertical (aumentando la capacidad del servidor).
NoSQL: Escala de manera horizontal (añadiendo más servidores o nodos), lo que lo hace más adecuado para manejar grandes cantidades de datos distribuidos.

4. Consultas:
SQL: Usa el lenguaje SQL para consultas complejas. Es potente y permite realizar uniones (JOINs) entre tablas.
NoSQL: Depende del tipo de base de datos, pero generalmente las consultas son más simples y menos estructuradas. No todas las bases de datos NoSQL soportan operaciones complejas como los JOINs.

5. Transacciones:
SQL: Proporciona ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad), lo que garantiza que las transacciones sean seguras y consistentes.
NoSQL: Muchas bases de datos NoSQL priorizan el rendimiento y la escalabilidad, por lo que no siempre garantizan ACID, aunque algunas ofrecen configuraciones de transacciones en un alcance limitado (por ejemplo, MongoDB con Multi-Document Transactions).

6. Casos de uso:
SQL: Ideal para aplicaciones con datos estructurados, como sistemas de gestión de relaciones (CRM), ERP, y aplicaciones financieras donde las relaciones entre datos son clave.
NoSQL: Mejor para aplicaciones con grandes volúmenes de datos no estructurados o semi-estructurados, como redes sociales, big data, análisis en tiempo real o aplicaciones móviles.

7. Ejemplos:
SQL: MySQL, PostgreSQL, Microsoft SQL Server, Oracle DB.
NoSQL: MongoDB, Cassandra, CouchDB, Redis, Firebase.
En resumen, las bases de datos SQL son más adecuadas para aplicaciones con datos muy estructurados y relaciones complejas, mientras que NoSQL ofrece flexibilidad y escalabilidad para manejar grandes volúmenes de datos no estructurados.



Básicamente, SQL trabaja con columnas y tablas, centralizando todo ahí dentro. Es una base de datos estructurada, que tiene lo que necesita tener. Es decir, tiene un esquema predefinido y relaciones entre los datos a través de claves primarias y foráneas. Debido a esta estructura rígida, no es tan apta para escalar horizontalmente como las bases de datos NoSQL.

En cambio, MongoDB no es relacional. Es decir, no usa tablas ni relaciones fijas entre los datos. En lugar de eso, utiliza documentos en formato JSON, que pueden tener diferentes estructuras y campos. Esto le da mucha más flexibilidad y la hace más apta para manejar grandes volúmenes de datos no estructurados o semi-estructurados. Además, MongoDB puede escalar de manera más eficiente horizontalmente, agregando más nodos según sea necesario.

Mientras que SQL es ideal para sistemas que requieren integridad de datos y relaciones complejas entre entidades (como aplicaciones bancarias o de inventarios), MongoDB y otras bases de datos NoSQL son mejores para aplicaciones que manejan grandes volúmenes de datos, como redes sociales, IoT o análisis de big data.



TIPOS DE BASE DE DATOS NoSQL

Clave-valor: Este tipo de base de datos almacena los datos como un par de clave y valor. Cada valor se asocia a una clave única, y es muy eficiente para buscar datos cuando conoces la clave. Es ideal para aplicaciones que necesitan almacenamiento rápido y simple, como cachés o configuraciones de usuario.

Documentales: En este tipo de base de datos, los datos se almacenan como documentos (normalmente en formato JSON o BSON). Cada documento puede tener diferentes campos y estructuras, lo que da mucha flexibilidad. MongoDB es un ejemplo de base de datos documental. Son útiles cuando los datos no tienen un esquema fijo o cambian con frecuencia.

Grafos: Las bases de datos de grafos están diseñadas para almacenar datos interconectados. Utilizan nodos, aristas y relaciones para representar la estructura de los datos. Son ideales para aplicaciones donde las relaciones entre los datos son clave, como redes sociales, recomendaciones y análisis de rutas.

Columnas: Las bases de datos basadas en columnas almacenan los datos en formato de columnas en lugar de filas, como en las bases de datos tradicionales SQL. Cada columna puede contener una gran cantidad de datos relacionados, lo que hace que sean muy eficientes para consultas analíticas sobre grandes volúmenes de datos. En lugar de leer filas completas (como en una base de datos relacional), solo se leen las columnas que realmente se necesitan, lo que mejora el rendimiento en ciertos casos.



INSTALACION DE MONGODB


WINDOWS

Vale, la instalacion es un poco tiquismiquis pero se puede

Ir a: "https://www.mongodb.com/try/download/community" y bajar hasta encontrar el boton "Download", podemos ingresar que tipo de instalacion queremos, yo escogi la msi por facil, y nos lo bajamos, luego instalamos el wizard, muy importante si lo quires como servicio o no, como servicio es que cada vez que ingreses a la maquina tendras al demonio mongod corriendo predeterminadamente, o bien si quieres no estar corriendolo hasta que lo habras tambien puedes, yo lo he hecho sin servicio, tambien nos podemos instalar el compass, pero da igual porque luego se puede instalar tambien.

Luego de esperar y alomejor dar consentimientos de algunas cosas tenemos que bajarnos la mongosh, la shell, en: "https://www.mongodb.com/try/download/shell" ingresamos las cosas y facil de instalar, yo he escojido msi, que es mas facil y automatico, tambien tenemos que ir a "C:\" y crear "data\db", vamos que tenemos que tener "C:\data\db" porque sino mongod no funcionara, luego de todo eso en "C:\Program Files\MongoDB\Server\8.0\bin" habra principalmente "mongod" que es el demonio, si eso no corre no nos conectara, lo ejecutamos y nos quedamos tranquilos, ya que el demonio esta listo nos podemos ir al "CMD" y podemos poner "mongosh" y veras que sale lo siguiente:

mongosh
Current Mongosh Log ID: 6761560c284f41d56779a1b5
Connecting to:          mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.3.6
Using MongoDB:          8.0.4
Using Mongosh:          2.3.6

For mongosh info see: https://www.mongodb.com/docs/mongodb-shell/

------
   The server generated these startup warnings when booting
   2024-12-17T11:44:18.959+01:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted
   2024-12-17T11:44:18.960+01:00: This server is bound to localhost. Remote systems will be unable to connect to this server. Start the server with --bind_ip <address> to specify which IP addresses it should serve responses from, or with --bind_ip_all to bind to all interfaces. If this behavior is desired, start the server with --bind_ip 127.0.0.1 to disable this warning
------

test>

Ya esta, ya estamos dentro, si no tenemos mongod arrancado saldria esto:

mongosh
Current Mongosh Log ID: 6761569bde1b27e5a079a1b5
Connecting to:          mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.3.6
MongoNetworkError: connect ECONNREFUSED 127.0.0.1:27017

Que no se puede conectar vamos, y tu estaras pensado, joder tengo que ir cada vez que quiera trabajar con mongodb tengo que ir a "C:\Program Files\MongoDB\Server\8.0\bin" y ejecutar el mongod, pues no, nos iremos al buscador y windows y pondremos "editar las variables de entorno del sistema" abajo en "Variables de entorno", clickaremos "Path" y luego "editar", "nuevo" y ponemos "C:\Program Files\MongoDB\Server\8.0\bin\", luego aceptamos todo y eso creara una variable para que no tengas que ir todo el rato a "C:\Program Files\MongoDB\Server\8.0\bin", con esa variable solo escribre "mongod" en el CMD y arrancara el demonio, luego en otra pestaña escribes "mongosh" y listo 



LINUX(Ubuntu):

Nos vamos a "https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/#std-label-install-mdb-community-ubuntu" para ver la documentacion(igualmnte pondre los comandos)

    -sudo apt-get install gnupg curl

    -curl -fsSL https://www.mongodb.org/static/pgp/server-8.0.asc | \
    sudo gpg -o /usr/share/keyrings/mongodb-server-8.0.gpg \
    --dearmor

    #dale "s"
    #si no se encuentra la comanda "curl" instala con "sudo apt install curl", y vuelve a poner el segundo comando

Selecciona tu distribucion de ubuntu

    -echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-8.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/8.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-8.0.list

    -sudo apt-get update

    -sudo apt-get install -y mongodb-org

    -ps --no-headers -o comm 1 #depende del que te salga tendras que tomar una opcion u otra en el comando de abajo

    -sudo systemctl start mongod #o sudo service mongod start

    -sudo systemctl start mongodb

    -sudo systemctl enable mongodb

    -mongosh


PRIMEROS PASOS EN MONGODB:

CREAR UNA BASE DE DATOS:
    -use NuevaBaseDeDatos
    switched to db NuevaBaseDeDatos

El use es para usar, pero si la db "NuevaBaseDeDatos" no existe mongodb la creara    

MOSTRAR LAS BASES DE DATOS:
    -show dbs
    admin    40.00 KiB
    config  108.00 KiB
    local    72.00 KiB

La db "Test" no es una db en si, es al principio donde nos posiciona para luego decidir cual es nuestro proximo movimiento, cuando salgas de "Test", esta no vuelve a salir    

*Aclaracion

No veras la base de datos que has creado hasta que haya colecciones dentro de ella

VER EL NOMBRE DE LA BASE DE DATOS EN USO:
    -NuevaBaseDeDatos> db.getName()
    NuevaBaseDeDatos

Tambien puedes usar:
    -test> db
    test
    test> use NuevaBaseDeDatos
    switched to db NuevaBaseDeDatos
    NuevaBaseDeDatos> db
    NuevaBaseDeDatos
    NuevaBaseDeDatos>

APAGAR EL SERVIDOR:
    -db.shutdownServer()


CREATE

CREACION DE COLECCION

Una vez "creada"(porque no se crea hasta que ingreses datos) la db hay que ingresar la coleccion:
    -db.nombredelacoleccion.insertOne()

Vamos a desglosarlo, el "db" hace referencia a la db donde estamos, en este caso "NuevaBaseDeDatos", el "nombredelacoleccion" es el nombre que queramos darle a la coleccion, y el "insertOne()" ya si es la funcion de ingresar un documento, entonces podemos poner algo como:

    -NuevaBase> db.usuarios.insertOne({nombre: "Alfredo", edad: 15}) //No lo he dicho pero tiene que tener formato JSON
    {
    acknowledged: true,
    insertedId: ObjectId('6762a3599715157f0579a1ba')
    }
    NuevaBase>

Y ahora si se vera la db "NuevaBase"
    -show dbs
    NuevaBase  40.00 KiB
    admin      40.00 KiB
    config     96.00 KiB
    local      72.00 KiB    

Aunque lo veas desde "Test"
    -test> show dbs
    NuevaBase  40.00 KiB
    admin      40.00 KiB
    config     96.00 KiB
    local      72.00 KiB
    test>

 Para ver las colecciones que tenemos en una db usamos:
    -show collections

Para borrar un coleccion es:
    -db.nombrecoleccion.drop()    

Cuidado si usas "show collections" en una db que no tenga colecciones o en "Test" sino no te saldra nada:
    -test> show collections

    test>

Hay que usarlo dentro de la db:
    -test> use NuevaBase
    switched to db NuevaBase
    NuevaBase> show collections
    usuarios
    NuevaBase>


VER CONTENIDO DE LA DB:
    -NuevaBase> db.usuarios.find() //El find encuentra
    [
    {
        _id: ObjectId('6762a3599715157f0579a1ba'),
        nombre: 'Alfredo',
        edad: 15
    }
    ]
    NuevaBase>

CREAR UNA COLECCION VACIA:

    -NuevaBase> db.createCollection("Nueva_Coleccion")
    { ok: 1 }
    NuevaBase> show dbs
    NuevaBase    8.00 KiB
    admin       40.00 KiB
    config     108.00 KiB
    local       72.00 KiB


COMENTAR:

Se puede comentar asi "//" o "/**/" para bloque, selecciona y copia el codigo de abajo:
    -show dbs //mostrar databases



ELIMINAR DB

Puedes eliminar todos las colecciones hasta que no haya ninguna con:
    -db.coleccion.drop()

O tambien puedes usar:
    -db.dropDatabase()

*ACLARACION:

Si creas un coleccion ya se vacia o con datos, no dejes espacios en ellos porque pasara algo como esto:
    -NuevaBase> db.createCollection("Nueva Coleccion")
    { ok: 1 }
    NuevaBase> show collections
    Nueva Coleccion
    NuevaBase> db.Nueva Coleccion.find()
    Uncaught:
    SyntaxError: Missing semicolon. (1:8)

    > 1 | db.Nueva Coleccion.find()
        |         ^
      2 |

Y para borrarla tiene tela porque no le vale esto:
    -db.Nueva Coleccion.drop()
    Uncaught:
    SyntaxError: Missing semicolon. (1:8)

    > 1 | db.Nueva Coleccion.drop()
        |         ^
      2 |

Tines que hacer esto:
    -db["Nueva Coleccion"].drop()
    true
    NuevaBase> show collections

    NuevaBase>


ID:

Cada documento tiene su _id aunque no se lo pongamos nosotro mongodb ya se encargara de ponerlo:
    -NuevaBase> db.usuarios.insertOne({nombre: "Claka", edad: 18}) //no le decimos nada de id:
    {
    acknowledged: true,
    insertedId: ObjectId('6762ae45474b8ec7c679a1b6') //mongodb ha visto que no tenemos un campo llamado _id, asique nos lo crea el
    }
    NuevaBase> db.usuarios.find()
    [
    {
        _id: ObjectId('6762ae45474b8ec7c679a1b6'), //se ve como este _id y el de arriba es el mismo
        nombre: 'Claka',
        edad: 18
    }
    ]


VARIABLES

Podemos crear nuestra propias variables en mongodb y luego insertarlas como si de JavaScript se refiere:

    -NuevaBase> let = documento = { _id: 1, nombre: "Teresa", edad: 67 }
    { _id: 1, nombre: 'Teresa', edad: 67 }
    -NuevaBase> documento
    { _id: 1, nombre: 'Teresa', edad: 67 }
    -db.usuarios.insertOne(documento)
    { acknowledged: true, insertedId: 1 }
    NuevaBase> db.usuarios.find()
    [
    {
        _id: ObjectId('6762ae45474b8ec7c679a1b6'),
        nombre: 'Alex',
        edad: 18
    },
    { _id: 1, nombre: 'Teresa', edad: 67 }
    ]
    NuevaBase>
    

*ACLARACION    

Siempre hemos podido poner el "_id", no solo es en la creacion de variables


Que pasara si volvemos a insertar la variable con el mismo "_id"?:
    -NuevaBase> db.usuarios.insertOne(documento)
    MongoServerError: E11000 duplicate key error collection: NuevaBase.usuarios index: _id_ dup key: { _id: 1 }
    NuevaBase>

Pues que no deja



READ

    -db.usuarios.find() //ver toda la db
    -db.usuarios.find({}) //ver toda la db
    -db.usuarios.find({nombre: "Carlos"}) //ver los documento cuyo nombre sea "Carlos", si no lo encuentra no devuelve nada

Cuando tienes mas de 20 documento y intentas verlos con "db.usuarios.find()" solo te mostrara los primeros 20, por si en la db tienes miles de documentos no sobresaturarlo, pero puedes hacer "db.usuarios.find().toArray()" para mostrarlos todos aunque sea una mala practica, en su lugar puedes hacer:
    -db.usuarios.find().forEach(empleadoData => { printjson(empleadoData)})

Filtrar por solo un campo:
    -db.usuarios.find({},{nombre: 1}) //solo te mostrara los 20 primeros documentos y solo mostrara los nombres y el _id
    -db.usuarios.find({},{nombre: 1}).toArray() //TODOS y solo mostrara los nombres y el _id

El _id sale por defecto pero podemos quitarlo tambien:
    -db.usuarios.find({},{nombre: 1, _id: 0})  //sino lo haces saldra siempre


Filtrar por anidamiento:
    venta: {
      pago: 'Efectivo',
      monto: 5,
      detalle: { responsable: 'Alex Serrano' }
    }

    -db.usuarios.find({"venta.detalle.responsable": "Alex Serrano"}) //usar las ""    

    
ordered inserts:

Es cuando ya tiene un documento con ese _id: X, y intentas ponerle otro igual junto a mas documentos, te saldra un error y no te deja insertar ninguno, aunque el otro tenga un _id valido.

EJemplo:

Tenemos 2 documentos en la db, uno con "el _id: 1" y el otro con el "_id: 2"
Estos: [ { _id: 1, nombre: 'Patricias' }, { _id: 2, nombre: 'Agustin' } ]

 y hago esto:
    -db.prueba.insertMany([{_id: 1, nombre: "Pedro"}, {_id: 3, nombre: "Bartolo"}])
    Uncaught:
    MongoBulkWriteError: E11000 duplicate key error collection: NuevaBase.prueba index: _id_ dup key: { _id: 1 }
    Result: BulkWriteResult {
    insertedCount: 0, //no ha insertado nada
    matchedCount: 0,
    modifiedCount: 0,
    deletedCount: 0,
    upsertedCount: 0,
    upsertedIds: {},
    insertedIds: {}
    }
    Write Errors: [
    WriteError {
        err: {
        index: 0,
        code: 11000,
        errmsg: 'E11000 duplicate key error collection: NuevaBase.prueba index: _id_ dup key: { _id: 1 }',
        errInfo: undefined,
        op: { _id: 1, nombre: 'Pedro' }
        }
    }
    ]

Un error de duplicidad por parte del "_id: 1" que intentamos insertar, pero que pasa?, que el "_id: 3" no tiene culpa y no se ha insertado, para eso esta el ordered, por defecto esta en "true" pero nosotros lo queremos en "false" para que funcione
    -db.prueba.insertMany([{_id: 1, nombre: "Pedro"}, {_id: 3, nombre: "Bartolo"}], {ordered: false})
    Uncaught:
    MongoBulkWriteError: E11000 duplicate key error collection: NuevaBase.prueba index: _id_ dup key: { _id: 1 }n //da el error de duplicado
    Result: BulkWriteResult {
    insertedCount: 1, //pero vemos que ha insertado un documento, antes no
    matchedCount: 0,
    modifiedCount: 0,
    deletedCount: 0,
    upsertedCount: 0,
    upsertedIds: {},
    insertedIds: { '1': 3 }
    }
    Write Errors: [
    WriteError {
        err: {
        index: 0,
        code: 11000,
        errmsg: 'E11000 duplicate key error collection: NuevaBase.prueba index: _id_ dup key: { _id: 1 }',
        errInfo: undefined,
        op: { _id: 1, nombre: 'Pedro' }
        }
    }
    ]
    NuevaBase> db.prueba.find()
    [
    { _id: 1, nombre: 'Patricias' },
    { _id: 2, nombre: 'Agustin' },
    { _id: 3, nombre: 'Bartolo' }
    ]  



UPDATE:

Vamos a ponerle una nueva clave llamada "etiqueta" al primero que se llame "Alex"

    -NuevaBase> db.usuarios.find()
    [
    {
        _id: ObjectId('6762ae45474b8ec7c679a1b6'),
        nombre: 'Alex',
        edad: 18
    },
    { _id: 1, nombre: 'Teresa', edad: 68 }
    ]
    NuevaBase> db.usuarios.updateOne({nombre: "Alex"}, { $set: {etiqueta: "atendido"}})
    {
    acknowledged: true,
    insertedId: null,
    matchedCount: 1,
    modifiedCount: 1,
    upsertedCount: 0
    }
    NuevaBase> db.usuarios.find()
    [
    {
        _id: ObjectId('6762ae45474b8ec7c679a1b6'),
        nombre: 'Alex',
        edad: 18,
        etiqueta: 'atendido'
    },
    { _id: 1, nombre: 'Teresa', edad: 68 }
    ]
    NuevaBase>

Tambien puedes eliminar:

NuevaBase> db.usuarios.find()
[
  {
    _id: ObjectId('6762ae45474b8ec7c679a1b6'),
    nombre: 'Alex',
    edad: 18,
    etiqueta: 'atendido',
    trabajo: true
  }
]
NuevaBase> db.usuarios.updateOne(
...   { nombre: "Alex" },
...   { $unset: { edad: "" } } //eliminamos la clave y el valor del campo edad, tambien puedes poner true en vez de los ""
... )
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
NuevaBase> db.usuarios.find()
[
  {
    _id: ObjectId('6762ae45474b8ec7c679a1b6'),
    nombre: 'Alex',
    etiqueta: 'atendido',
    trabajo: true
  }
]


Tambien puedes actualizar por el "ObjectID":

    -db.usuarios.updateOne({ _id: ObjectId('676412da0251d01c9379a1b7') }, { $set: { nombre: "Mariano" }}) //puedes actualizar cojiendo el filtro de lo que quieras


DELETE 

El metodo deletOne() y deletMany() borra documentos, no borra una clave-valor, borra el documento en si

    -db.usuarios.deleteMany({}) //borra toda la base
    -db.usuarios.deleteOne({}) //borra el primer documento de la db
    -db.usuarios.deleteOne({nombre: "Maria"}) //Borra el documento de maria, NO SOLO BORRA EL NOMBRE "MARIA", eso en update con el $unset


ARRAYS

En los documentos se pueden tener arrays tambien:
    -db.empleados.insertOne({nombre: "Marcus Ortega", email: "marcus@example.com", empleado: "si", diasLaborables: ["Sabado", "Domingo"]})
    -db.empleados.updateOne({nombre: "Lewis Coleman"}, { $set : {diasLaborables: ["Lunes", "Martes", "Miercoles", "Jueves", "Viernes"]}})

Filtrar por arrays:
    -db.empleados.findOne({nombre: "Marcus Ortega"}).diasLaborables //tiene que ser el mismo nombre proporcionado en el documento
    -


DESCARGAR MONGOIMPORT WINDOWS:

En "https://www.mongodb.com/try/download/database-tools" elegimos la opcion de msi

Vamos a "C:\Program Files\MongoDB\Tools\version\bin", hay estan los archivos que tenemos que pasar a "C:\Program Files\MongoDB\Server\version\bin"

Poneros cada ventana del "Explorador de archivos" y ir copiando a la "C:\Program Files\MongoDB\Server\version\bin"

*Aclaracion:

Lo que hemos hecho es para poder importar documentos de nuestra maquina al servidor, NO FUNCIONA LA COMANDa "mongoimport" DENTRO DEL SERVIDOR, es como "mongod" que se tiene que hacer el "CMD".

Comando:
    -mongoimport .\product.json -d product -c productData --jsonArray --drop

mongoimport: la opcion de importar
.\product.json: el archivo que queremos importar
-d product: a la database product //si no existe la crea
-c productData: a la coleccion productData //si no existe la crea
--jsonArray: si el archivo tiene Array //si los tiene y lo pones no funcionara
--drop: Si existe la base de datos la eliminara y hara el comando



OPERADORES

$eq: Igual que - db.LosProductos.find({productName: {$eq: "Chai"}}) // es lo mismo que - db.LosProductos.find({productName: "Chai"})

$ne: Diferente de - db.LosProductos.find({branchOffice: {$ne: "Florida"}})

$gt: Mayor que - db.LosProductos.find({unitsInStock: { $gt: 43}}) //mayor que 43, el 43 no incluido

$gte: Mayor o igual que - db.LosProductos.find({unitsInStock: { $gte: 43}}) //mayor o igual a 43, 43 incluido

$lt: Menor que - db.LosProductos.find({unitsInStock: { $lt: 43}}) //menor que 43, 43 no incluido

$lte: Menor o igual que - db.LosProductos.find({unitsInStock: { $lte: 43}}) //menor o igual a 43, 43 incluido

$in: Valor en una matriz - db.LosProductos.find({branchOffice: {$in: ["Florida"]}}) // es lo mismo que - db.LosProductos.find({branchOffice: "Florida"})

$nin: Valor no está en una matriz/Array - db.LosProductos.find({branchOffice: {$nin: ["Florida", "California", "Ohio"]}})


OPERADORES LOGICOS

$and: une dos o mas valores si son verdaderos - db.LosProductos.find({ $and: [{ "discountDay.Monday": { $gt: 0.25 } }, { branchOffice: "Florida" }] }, { "discountDay.Monday": 1, branchOffice: 1 }) //es lo mismo que db.LosProductos.find({ "discountDay.Monday": { $gt: 0.25 }, branchOffice: "Florida" }, { "discountDay.Monday": 1, branchOffice: 1 }) //esta buscando los documentos que el discountDay.Monday sera mayor a 0.25 y que este en la sucursal de Florida, junto a unas proyecciones

$or: une dos valores si alguno de ellos es verdadero - db.LosProductos.find({$or: [{"categories.categoryName": {$eq: "Confections"}}, {"categories.categoryName": {$eq: "Produce"}}]})

$not: niega la condición dada, selecciona documentos donde no se cumpla - db.LosProductos.find({branchOffice: {$not: {$in: ["California", "Misuri"]}}},{branchOffice: 1}) 

$nor: selecciona documentos donde NINGUNA de las condiciones sea verdadera(basicamente en un $and pero los 2 valores tienen que ser falsos, lo contrario del $and) - db.LosProductos.find({ $nor: [{ branchOffice: "California" }, { branchOffice: "Misuri" }] }, { branchOffice: 1 })


OPERACIONES DE CONSULTA

$exist: Busca en un documento si exixte/o no la clave que queramos - db.empleados.find({ age: {$exists: true}}) // tambien puedes poner false para buscar por los que no existan(he hecho esto por diversion: db.empleados.find({ age: {$not: {$exists: true}}})), es lo mismo que db.empleados.find({ age: {$exists: false}})

$type: verifica el tipo de dato - db.empleados.find({homePhone: {$type: "number"}}), puedes hacer que filtre X2 tambien: db.empleados.find({homePhone: {$type: ["number", "string"]}})

ACLARACION

Aunque "db.empleados.find({$and: [{age: {$exists: true}}, {age: {$gt: 35}}]})" y "db.empleados.find({ age: {$exists: true, $gt: 35}})" hagan lo mismo yo te recomiendo el segundo porque como ya hemos dicho cuando hacemos un db.empleados.find({},{}) es igual al $and


OPERADORES DE EVALUACION

$regex: busca patrones en cadenas de texto usando expresiones regulares - db.empleados.find({description: {$regex: "travel"}}) //salen todos los documentos que tengan la palabra "travel" en el campo de description


    -db.empleados.find({title: {$regex: "support"}})
Puedes añadir opciones a las busquedas con $regex con $options($options SOLO ESTA SI USAS $regex, NO SE PUEDE USAR SINO), el comando de arriba solo busca exactamente por "support" pero podemos hacer que no:

    -db.empleados.find({title: {$regex: "support", $options: "i"}}) //sin importar mayusculas o minusculas

Para que acaben con una letra o palabra determinada:
    -db.empleados.find({ firstName: { $regex: "y$" } } )  

Tambien puedes buscar caracteres asi:
    -db.empleados.find({ description: /loves/ })

$expr: Permite usar expresiones que comparan valores de campos o realizan cálculos - db.empleados.find({$expr: {$lt: ["$delay", "$tolerance"]}}) //estara devolviendo los documentos que $delay no sea mayor a $tolerance  //tambien puedes usar $eq, $gt, $ne,         

$mod: No se muy bien lo que hace - db.empleados.find({ age: { $mod: [2, 0] } }) //devuelve los documento que age sea par, solo coje el entero, un $mod: [2.66, 0] NO, cojeria solo el primero, el 2


OPERACIONES DE ARRAYS

$all: verificar si un campo de tipo arreglo contiene todos los valores especificados - db.empleados.find({state: {$all: ["Florida", "Ohio"]}}) //igual que: db.empleados.find({$and: [{state: {$eq: "Florida"}}, {state: {$eq: "Ohio"}}]})

$elemMatch: coincide con documentos que contienen un campo de matriz con al menos un elemento que coincide con todos los criterios de consulta especificados. - db.empleados.find({hobbies: {$elemMatch: {title: "Dance"} }}) //tambien: db.empleados.find({hobbies: {$elemMatch: {title: "Voley", frequency: {$gte: 3}}}})

$size: verificar la cantidad de elementos en un arreglo/array - db.empleados.find({hobbies: {$size: 2}}) //tambein: db.empleados.find({state: {$size: 5}})



METODO CURSOR

.next(): obtiene un solo documento a la vez del cursor, lo que da más control sobre la iteración, ya que debes llamarlo repetidamente para acceder a cada documento. Por otro lado, .it (utilizado en la shell interactiva de MongoDB) permite recorrer automáticamente todos los documentos del cursor, devolviendo uno a uno sin necesidad de llamarlo explícitamente cada vez, lo que facilita iterar sobre todos los resultados sin control manual.

.hasNext(): Devuelve un booleado de si puedes hacer otro .next() o no, es solo informativo

.sort(): Devuelve los documentos ordenados - db.LosProductos.find().sort({id: 1})//Los ordena ascendente, si quieres que sea descente es con "-1"

.toArray(): Devuelve todos los documentos del la db especificados

.skip(): Omite los primeros X documentos de la consulta - db.LosProductos.find().sort({ id: 1 }).skip(10) //se ordenan en ascendente pero se omiten los 10 primeros:

    -db.LosProductos.find().sort({ id: 1 }).skip(10).toArray()
[
  {
    _id: ObjectId('6767fdfa2e58910481c31b8e'),
    id: 11, //empieza por el id 11

.limit(): Limita el número de documentos que se devuelven a X - db.LosProductos.find().sort({ id: 1 }).skip(10).limit(15) //se ordenan en ascendente pero se omiten los 10 primeros y solo habra 15 documentos

.count(): Te dice cuantos documentos tienes(ponlo siempre en el final de la comanda):

    -db.LosProductos.find().count()
    63

Asi no:
    -db.LosProductos.find().count().limit(15)
    TypeError: db.LosProducto ... ount().limit is not a function
Asi:
    -db.LosProductos.find().limit(15).count()
    15


OPERADORES DE PROYECCION    

".$": La proyección con ".$": Devuelve únicamente el primer elemento de un array que cumple con la condición especificada en el filtro. Esto permite mostrar solo el dato relevante en lugar de devolver el array completo - db.empleados.find({"hobbies.frequency": {$gte: 3}}, {"hobbies.frequency.$": 1}) //o "hobbies.$": 1

$slice: itar la cantidad de elementos devueltos de un array en los documentos resultantes - db.empleados.find({},{score: {$slice: 2}})//devuelve el "0" y "1", los 2 primeros vaya, si quieres los 2 ultimos pues -2



PROFUNDIZANDO CON OPERACIONES UPDATE

-replaceOne(): reemplaza completamente un documento existente en una colección con un nuevo documento. Es útil cuando quieres modificar un documento entero en lugar de actualizar campos específicos - db.movies.replaceOne({title: 'Toy Story 3'}, {movieID: 'mv06', title: "Toy Story 3", runtime: 103, voteAverage: 7.6, dateRelease: "2015-08-15", dateExpired: "2015-11-15", isView: true}) // es util por si quieres cambiar un solo documento, no pequeñas cosas de el

-updateOne(): actualiza el primer documento que cumpla con un filtro específico, aplicando los cambios definidos, incluso si no existe el campo que quieras añadir - db.movies.updateOne({title: "Toy Story 3"}, {$set: {voteAverage: 64}}) // si existiera el campo voteAverage lo hubiera cambiado a 64, sino existia lo crea y le da el valor de 64

-updateMany(): Lo mismo que el updateOne() pero con los que cumplan con el filtro - db.movies.updateMany({}, {$set: {lenguaje: "in", price: 7}}) // no existia ningun campo:
    -db.movies.updateMany({}, {$set: {lenguaje: "in", price: 7}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 7,
  modifiedCount: 7,
  upsertedCount: 0
}

Si volvieramos a ejecutar el comando "db.movies.updateMany({}, {$set: {lenguaje: "in", price: 7}})" no pondria:

{
  acknowledged: true,
  insertedId: null,
  matchedCount: 7, //se encuentran 7 documentos
  modifiedCount: 0, //pero como no hay nada ha cambiar no se cambia nada
  upsertedCount: 0
}

$inc: utiliza para incrementar o decrementar valores numéricos de un campo en un documento. Si el campo no existe, $inc lo crea con el valor proporcionado - db.movies.updateOne({movieID: 'mv07'}, {$inc: {price: 6}}) //le suma 6 al valor que havia antes, si quieres que reste pondias un "-", "-6"

Tambien puedes crear nuevas claves-valores con $inc: db.movies.updateMany({},{$inc: {"%tax": 0.2}}) //le asigna a todos los documentos una nueva clave llamada "%tax" con el valor de "0.2" o "20%" tambien

$min: actualizar el valor de un campo únicamente si el valor proporcionado es menor que el valor actual del campo. Si el campo no existe, $min lo añade con el valor proporcionado - db.movies.updateMany({},{$min: {VoteAverage: 7.5}}) //actualiza los campos que si "VoteAverage" sea mayor que "7.5" y le pone ese valor, si el "VoteAverage" es 9 despues de la comando puesta su valor sera de 7.5

$max: actualizar el valor de un campo únicamente si el valor proporcionado es mayor que el valor actual del campo. Si el campo no existe, $max lo añade con el valor proporcionado(lo contrario que el $min) - db.movies.updateMany({},{$max: {VoteAverage: 6}}) //los que sean inferior a 6 los convertira a 6

Un truco, si te lias con $min y $max piensa que de lo que estas pensando es al reves, me explico, cuando piensas en $min piensas en minimo obvio, pues no, en la comanda: "db.movies.updateMany({},{$min: {VoteAverage: 7.5}})" lo que hace es buscar los que sean MAYOR a 7.5, NO MENOR, LOS QUE SEAN MAYOR A 7.5 LOS CONVERTIRA A 7.5, y pasa lo mismo que con $max solo que no es "maximo", es menor, si cambiamos la comanda de antes el $min por el $max lo que hara es buscar a LOS MENORES A 7.5 y los convertira en 7.5

$mul: multiplicar el valor de un campo por un número especificado - db.movies.updateOne({movieID: 'mv07'},{$mul: {price: 2}}) //si price valia 7, ahora vale 14

$rename: cambiar el nombre de una clave en un documento - db.movies.updateMany({},{$rename: {'%tax': "percentTax"}}) // cambia la clave "%tax" por "percentTax"

ACLARACION

Solo cambia la clave no el valor, aqui un error comun: db.movies.updateOne({movieID: 'mv07'},{$rename: {title: "Minions 2"}}) //lo que estas haciendo es cambiar la clave "title" por "Minions 2", lo que quedaria asi: 'Minions 2': 'Minions'

$unset: eliminar un campo específico de un documento. Cuando se aplica, el campo desaparece por completo del documento, junto con su valor. - db.movies.updateMany({},{$unset: {percentTax: 1}}) //elimina "percentTax" junto a su valor en todos los documentos, (en vez de poner un 1 tambien puedes usar "")

$currentDate: establecer el valor de un campo como la fecha y hora actuales - db.movies.updateOne({title: 'Minions'},{$currentDate: {dateRelease: true}})// obvio que solo funciona con fechas, tambien puedes usar: db.movies.updateOne( { title: 'Minions' }, { $currentDate: { dateExpired: { $type: "date" } } } );

$push: Añade un elemento al array - db.empleados.updateOne({employeeID: 5}, {$push: {score: 50}})

$addToSet: Añade un elemento único al array (sin duplicados) - db.empleados.updateOne({employeeID: 5}, {$addToSet: {score: 81}}) // si pones un numero que ya estaba en la array: modifiedCount: 0

$pull: Elimina un elemento del array - db.empleados.updateOne({employeeID: 5}, {$pull: {score: 81}}) //si intentas quitar un numero que no esta: modifiedCount: 0

upsert: El parámetro upsert en MongoDB permite combinar las operaciones de actualización e inserción. Si el documento especificado en el filtro no existe, MongoDB crea uno nuevo usando los datos de la operación de actualización; si ya existe, simplemente lo actualiza - db.movies.updateOne({movieID: "MVO8"}, {$set: {title: "Capitan America"}}, {upsert: true}) //El movieID "MV08" NO EXISTE, lo que queremos hacer aqui es añadirlo si no existe o actualizarlo en caso de que si exista, si no existe el parametro upsert se encargara de crearlo y saldra asi: upsertedCount: 1 ya que lo ha insertado, si el movieID "MV08" SI HUBIESE EXISTIDO el title que hubiera en el movieID "MV08" se cambiara por el ingresado en la comanda, en este caso "Capitan America"

$setOnInsert: se usa en operaciones de actualización con la opción upsert. Permite especificar los campos que deben establecerse solo cuando se inserta un nuevo documento (es decir, cuando el filtro no encuentra coincidencias y se crea un nuevo documento). Si el documento ya existe y se actualiza, los campos definidos en $setOnInsert no se aplican -

db.movies.updateOne(
  { movieID: "mv02" }, // Filtro: busca el documento con movieID "mv02"
  {
    $set: { title: "Interstellar", year: 2014 }, // Si existe, actualiza estos campos
    $setOnInsert: { genre: "Sci-Fi" } // Si se inserta, agrega el campo "genre"
  },
  { upsert: true } // Si no existe, crea un nuevo documento
);




OPERADOR POSICIONAL DE ARRAY ($)

$: db.movie.updateOne({movieID: "mv01", ratings: 70}, {$set: {"ratings.$": 71}}) - La comanda busca un documento con movieID: "mv01" y un 70 en el array ratings, luego actualiza el primer 70 encontrado a 71, otro: db.movie.updateMany({productionCompany: {$elemMatch: {employee: {$eq: 70}, hoursWorkedAverage: {$gt: 9}}}}, {$set: {"productionCompany.$.salaryAverage": 8000}})

$[]: Actualiza todos los elementos de un array dentro de un documento que coincidan con la consulta - db.movie.updateMany({movieID: {$in: ["mv01", "mv02"]}}, {$inc: {"ratings.$[]": 5}}) // otra: db.movie.updateMany({movieID: {$in: ["mv06", "mv07"]}}, {$set: {"productionCompany.$[elem].salaryAverage": 5000}}, {arrayFilters: [{"elem.employee": {$gte: 60}}]}), //otra: db.movie.updateMany({movieID: {$in: ["mv06", "mv07"]}}, {$inc: {"productionCompany.$[elem].employee": -10}}, {arrayFilters: [{"elem.name": "Marvel Studios", "elem.salaryAverage": 5000}]})


OPERADORES MODIFICADORES DE ACTUALIZACION

$each: se utiliza con operadores como $push o $addToSet para agregar múltiples valores a un array - db.movie.updateOne({movieID: 'mv07'}, {$addToSet: {language: {$each: ["Spanish", "English", "French"]}}})

$position: Se utiliza con $push para especificar la posición exacta donde insertar elementos en un array. Por defecto, $push agrega los elementos al final, pero con $position puedes insertar en cualquier índice del array - db.movie.updateOne({ movieID: 'mv07' }, { $push: {ratings: {$each: [10,20,30], $position: 0}}}) // lo añade la principio(en la posicion 0 de la cadena)

$slice: El operador $slice en MongoDB se utiliza junto con $push y $each para limitar el tamaño de un array después de insertar nuevos elementos. Esto es útil cuando quieres mantener un array con un número máximo de elementos, eliminando los más antiguos o los últimos según el orden - db.movie.updateOne({movieID: "mv05"}, {$push: {productionCompany: {$each: [{name: "Revolution Sun Studios", employee: 65, salaryAverage: 4500, hoursWorkedAverage: 8}], $slice: -2 }}}) //añadira ese documento y dejara los dos ultimos

otro: db.movie.updateOne({movieID: "mv05"}, {$push: {ratings: {$each: [94,98], $position: 0, $slice: 4 }}})//añade 94 y 98 al principio de la array y solo enseña los 4 primeros

$sort: se utiliza junto con $push y $each para ordenar los elementos de un array después de insertar nuevos valores. Es especialmente útil cuando deseas mantener un array ordenado automáticamente, ya sea en orden ascendente o descendente - db.movie.updateOne({ movieID: "mv05" }, { $push: { ratings: {$each: [3,9,7,5,1], $sort: 1} } } ) //si no quieres que se añada ningun documento y solo quieres ordenar deja la array vacia, []

otro: db.movie.updateOne({ movieID: "mv05" }, { $push: { productionCompany: {$each: [{name: "Illumination Entertaiment", employee: 45, salaryAverage: 5000, hoursWorkedAverage: 7}], $sort: {employee: 1}, $slice: 2} } } ) //añade un documento nuevo y de ordenara segun el los employee y cojera los 2 primeros

$pop: elimina un elemento de un array al principio o al final, dependiendo del valor que le asignes - db.movie.updateOne({movieID: "mv05"}, {$pop: {ratings: -1}})// el 1 elimina el ultimo y el -1 elimina el primero

$pullAll: eliminar todos los valores especificados de un array dentro de un documento - db.movie.updateOne({movieID: "mv05"}, {$pullAll: {language: ["Italiano", "Latin"]}}) 



TIPOS DE DATOS

NO NUMEROS

Saber que tipo de dato es un valor:
    -typeof db.data.findOne().user 

Antes lo haciamos asi:
    -db.data.find({user: {$type: "string"}}) //podriamos poner tanto boolean, number, etc...

Pero si no sabes que tipo es un valor yo te recomiendo la primera, es mas directa, la segunda es mas para filtar por los que tengan ese tipo no es para salir de dudas si no sabes que tipo es    

Puedes ver informacion de la db actual:
    -db.stats()

Puedes ver informacion de la coleccion actual:
    -db.coleccion.stats()

Puedes buscar por un valor en especifico:
    -db.coleccion.stats().size  

Puedes insertar el tipo de dato que tu quieras tambien en mongodb:
    -db.coleccion.insertOne({valor: Int32(30)}) //si pasa de cierto numero larguisimo dara erro y tendras que llamarlo con NumberLong

    rango de valores desde -2,147,483,648 hasta 2,147,483,647 con Int32
    rango de valores desde -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 con NumberLong

fECHAS    

Con este comando puedes capturar la fecha actual diferente de como seria "new Date("xxxx-xx-x")" o ISODate("xxxx-xx-xx"):
    -db.data.updateMany({},{$set: {FechaActual: Date()}})

Saldria algo asi:
        FechaActual: 'Sat Jan 11 2025 11:43:35 GMT+0100 (hora estándar de Europa central)'


Usa ISODate cuando trabajes directamente con MongoDB, especialmente si estás insertando o consultando documentos en la base de datos.
Usa new Date si estás manejando fechas desde JavaScript y necesitas construir o manipular datos antes de enviarlos a MongoDB.

Timestamp

    -db.data.updateMany({},{$set: {con_timestamp: new Timestamp()}})

Te dara algo asi o no:

con_timestamp: Timestamp({ t: 0, i: 0 })

Lo actualizaremos:
    -db.data.updateMany({}, {$currentDate: {con_timestamp: {$type: "timestamp"}}})

Y ahora si

con_timestamp: Timestamp({ t: 1736592921, i: 1 })



Recomendación para usar números en MongoDB:
Usa int32 para datos pequeños como edades, cantidades o IDs dentro de un rango limitado.
Usa int64 cuando necesites manejar enteros grandes como números de serie o totales acumulados.
Usa double para datos que incluyen fracciones o cuando la precisión decimal no sea crítica.
Usa Decimal128 si trabajas con datos financieros o cálculos que requieran una precisión exacta.


int32 (32-bit Integer):
Constructor: Int32(30). //tampoco hace falta especificarlo ya que se pone predeterminado
Ejemplo: { "edad": 25 }


int64 (64-bit Integer):
Constructor: NumberLong(838383615611093745)
Ejemplo: { "grandesVentas": NumberLong(9223372036854775807) }


double (64-bit Floating Point):
Constructor: Number()
Ejemplo: { "precio": Number(199.99) }
Decimal128 (128-bit Decimal):

Constructor: NumberDecimal()
Ejemplo: { "saldo": NumberDecimal("123456.789") }



No te comas mucho la cabeza pensando



MODELO DE DATOS

El modelo de datos no es más que la forma en que decides estructurar los datos dentro de los documentos y cómo gestionas las relaciones entre ellos.

1. Relación Uno a Uno
Definición: Un elemento de una colección está relacionado con exactamente un elemento de otra colección.
Ejemplo: Un usuario tiene una tarjeta de identificación.
Implementación:
Incrustar: Si siempre necesitas ambos datos juntos.

{
  "_id": 1,
  "nombre": "Alex",
  "identificacion": {
    "tipo": "DNI",
    "numero": "123456789"
  }
}
Referenciar: Si los datos de identificación se gestionan aparte.

{
  "_id": 1,
  "nombre": "Alex",
  "identificacion_id": "A123"
}
2. Relación Uno a Muchos
Definición: Un elemento de una colección está relacionado con muchos elementos de otra colección.
Ejemplo: Una categoría tiene varios productos.
Implementación:
Incrustar: Si el número de productos por categoría es pequeño.

{
  "_id": 1,
  "categoria": "Electrónica",
  "productos": [
    { "nombre": "Teléfono", "precio": 300 },
    { "nombre": "Laptop", "precio": 1000 }
  ]
}
Referenciar: Si hay muchos productos o se reutilizan en varias categorías.

{
  "_id": 1,
  "categoria": "Electrónica",
  "productos_ids": [101, 102]
}
3. Relación Muchos a Muchos
Definición: Muchos elementos de una colección están relacionados con muchos elementos de otra colección.
Ejemplo: Usuarios que tienen roles múltiples, y cada rol puede pertenecer a varios usuarios.
Implementación:
Intersección con una colección puente: Usas una colección extra para almacenar las relaciones.
Usuarios:

{ "_id": 1, "nombre": "Alex" }
{ "_id": 2, "nombre": "Rodolfo" }
Roles:
json
Copiar código
{ "_id": 101, "rol": "Admin" }
{ "_id": 102, "rol": "Editor" }
Relaciones (puente):

{ "usuario_id": 1, "rol_id": 101 }
{ "usuario_id": 1, "rol_id": 102 }
{ "usuario_id": 2, "rol_id": 102 }

*Aclaracion:

Una estructura "ideal" en MongoDB seria que no falten valores, ejemplo de estructura mala:

[
  {
    _id: ObjectId('6783a45b079082d76b79a1b6'),
    name: 'Jamon',
    price: 2
  },
  {
    _id: ObjectId('6783a483079082d76b79a1b7'),
    name: 'tablet',
    price: 200,
    detail: { storage: 256, ram: 12 } //aqui hay detail y en el otro documento no
  }
]

Asi seria mejor:

[
  {
    _id: ObjectId('6783a45b079082d76b79a1b6'),
    name: 'Jamon',
    price: 2
    detail: null
  },
  {
    _id: ObjectId('6783a483079082d76b79a1b7'),
    name: 'tablet',
    price: 200,
    detail: { storage: 256, ram: 12 }
  }
]

Aunque no haya detalles



VALIDAR CAMPOS OBLIGATORIOS Y VALORES DE CAMPO

La validación de campos asegura que los datos ingresados o almacenados en una base de datos cumplan con ciertos criterios predefinidos. Esto ayuda a prevenir errores, inconsistencias y datos no deseados.

db.createCollection( "product", { //crea la coleccion "product"
    validator: { //añade un validador
        $jsonSchema: { 
            bsonType: "object", //acepta documentos
            required: [ "name", "price", "ammount", "available", "orderDate" ], //requiere estos campos obligatorios, pero puedes agregar nuevos
            description: "Los campos name, price, ammount, available y orderDate son obligatorios.", //por si sale error
            properties: { //propiedades que tienen que tener los campos
                name: {
                    bsonType: "string", //tipo de dato
                    description: "Solo acepta tipo de dato string." //si sale error
                },
                price: {
                    bsonType: "double", //tipo de dato       //tambien puedes poner varios con una [], ejemplo: ["string", "number"]
                    description: "Solo acepta valores decimales." //si sale error
                },
                ammount: {
                    bsonType: "int", //tipo de dato       //tambien puedes poner varios con una [], ejemplo: ["string", "number"]
                    description: "Solo acepta valores enteros." //si sale error
                },
                available: {
                    bsonType: "bool", //tipo de dato       //tambien puedes poner varios con una [], ejemplo: ["string", "number"]
                    description: "Solo acepta true o false." //si sale error
                },
                orderDate: {
                    bsonType: "date", //tipo de dato       //tambien puedes poner varios con una [], ejemplo: ["string", "number"]
                    description: "Solo acepta fecha." //si sale error
                }
            }
        }, //QUITAR O PONER LA , SI QUIERES/NO QUIERES LAS "additionalProperties"
        "additionalProperties": false //esto es por si solo quieres que se pongan los campos que hayas requerido, NO MAS, tambien tendras que poner la propiedad de _id, porque todo documento necesita un _id 
    } 
} )


Mismo comando en una linea:
    -db.createCollection("product", { validator: { $jsonSchema: { bsonType: "object", required: ["name", "price", "ammount", "available", "orderDate"], description: "Los campos name, price, ammount, available y orderDate son obligatorios.", properties: { name: { bsonType: "string", description: "Solo acepta tipo de dato string." }, price: { bsonType: "double", description: "Solo acepta valores decimales." }, ammount: { bsonType: "int", description: "Solo acepta valores enteros." }, available: { bsonType: "bool", description: "Solo acepta true o false." }, orderDate: { bsonType: "date", description: "Solo acepta fecha." } } } } });


VALIDAR MAXIMOS Y MINIMOS


db.createCollection( "user", {
    validator: { 
        $jsonSchema: { 
            bsonType: "object",
            required: [ "name", "age"],
            description: "Los campos name y age son obligatorios",
            properties: { 
                name: {
                    bsonType: "string",
                    description: "Solo acepta tipo de dato string." 
                },
                age: {
                    bsonType: "int",
                    minimum: 20, //minimo
                    maximum: 110, //maximo
                    description: "Solo acepta valores enterros y que sea entre 18 y 100 años"
                }
            }
        }
    } 
} )


VALIDAR SUBDOCUMENTOS

db.createCollection( "customer", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: [ "name", "age", "address" ], //nuevo campo address
            description: "Los campos name, age y address son obligatorios.",
            properties: {
                name: {
                    bsonType: "string",
                    description: "Agregar el nombre del cliente."
                },
                age: {
                    bsonType: "int",
                    minimum: 18,
                    maximum: 110,
                    description: "La edad debe estar entre el rango de 18 a 110 años."
                },
                address:{ //propiedades de address
                    bsonType: "object", //tipo object ya que es un documento
                    required: [ "country", "city", "avenue" ], //tambien puede requerir sus propios valores
                    description: "Los campos country, city y avenue son obligatorios",
                    properties: { //a partir de aqui ya te imaginas
                        country: {
                            bsonType: "string",
                            description: "Debe ingresar el nombre del país."
                        },
                        city: {
                            bsonType: "string",
                            description: "Debe ingresar el nombre de la ciudad."
                        },
                        avenue: {
                            bsonType: "string",
                            description: "Debe ingresar la avenida de su domicilio."
                        }
                    }
                }
            }
        }
    }
} )


VALIDAR ARRAYS

db.createCollection( "employee", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            properties: {
                employees: {
                    bsonType: "array",
                    description: "Debemos agregar una matriz.",
                    items: {
                        bsonType: "object",
                        required: [ "name", "lastName" ],
                        properties: {
                            name: {
                                bsonType: "string",
                                description: "Debe ingresar el nombre."
                            },
                            lastName: {
                                bsonType: "string",
                                description: "Debe ingresar el apellido."
                            }
                        }
                    }
                }
            }
        }
    }
} )


db.employee.insertOne(
    {
        employees: [
            {
                name: "Hugo",
                lastName: "Fernandez"
            },
            {
                name: "Marco",
                lastName: "Prado"
            },
            {
                name: "Micaela",
                lastName: "Rojas"
            }
        ]
    }
)


Consultar TODAS las validaciones:
    -db.getCollectionInfos()

Consultar UNA validacion:
    -db.getCollectionInfos({name: "Coleccion"})    


MODIFICAR LA VALIDACIÓN DE ESQUEMA

Cambiar como se valida una coleccion:
    -db.runCommand( { collMod: "user", //con CollMod decimos que queremos cambiar la validacion de la coleccion "user"
        validator: { 
            $jsonSchema: { 
                bsonType: "object",
                required: [ "name", "age"],
                description: "Los campos name y age son obligatorios",
                properties: { 
                    name: {
                        bsonType: "string",
                        description: "Solo acepta tipo de dato string." 
                    },
                    age: {
                        bsonType: "int",
                        minimum: 20, //minimo
                        maximum: 110, //maximo
                        description: "Solo acepta valores enterros y que sea entre 18 y 100 años"
                    }
                }
            }
        }
    })




VALIDAR LISTA DE VALORES EN UN ARRAY

Tambien puedes validar una array:

db.createCollection("color", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["color"],
            properties: {
                color: {
                    bsonType: "array",
                    description: "Agregar los colores disponibles del producto.",
                    items: {
                        bsonType: "string",
                        enum: ["Rojo", "Azul", "Amarillo", "Verde"] // solo acepta estos valores
                    },
                    minItems: 1 // mínimo puede haber 1 elemento
                }
            }
        }
    }
})


*ACLARACION

Si insertas un documento con solo el campo x (por ejemplo: { x: "x" }) y luego configuras una validación que requiere un campo adicional llamado y, MongoDB no aplicará retroactivamente las validaciones a los documentos existentes. Esto significa que el documento que ya está en la colección no se verá afectado y permanecerá intacto.

Sin embargo, después de habilitar la validación, cualquier operación de escritura (como insertar o actualizar documentos) que no cumpla con las nuevas reglas de validación será rechazada.




El validationLevel es una opción en MongoDB que determina cómo se aplican las reglas de validación en una colección. Afecta si los documentos existentes o ciertas operaciones de escritura están sujetos a las reglas de validación configuradas.

Valores de validationLevel
MongoDB soporta tres valores principales para esta configuración:

strict (predeterminado):

Reglas de validación aplicadas estrictamente.
Todas las operaciones de escritura (inserciones y actualizaciones) deben cumplir con las reglas de validación. Si un documento no cumple, la operación se rechaza.
Nota: Los documentos existentes antes de la configuración de validación no se ven afectados, pero cualquier actualización que intente modificar un documento debe cumplir con las reglas.

db.runCommand({
    collMod: "miColeccion",
    validator: { $jsonSchema: { bsonType: "object", required: ["x"] } },
    validationLevel: "strict"
});
moderate:

Validación aplicada solo a documentos que cambian.
Durante las actualizaciones, MongoDB valida solo los documentos que se están modificando.
No bloquea documentos existentes que no cumplan con las reglas de validación, siempre y cuando la operación de escritura no modifique esos documentos.

db.runCommand({
    collMod: "miColeccion",
    validator: { $jsonSchema: { bsonType: "object", required: ["x"] } },
    validationLevel: "moderate"
});
off:

Desactiva la validación.
MongoDB no valida ningún documento al momento de realizar operaciones de escritura, pero las reglas de validación siguen estando configuradas y pueden reactivarse más tarde.

db.runCommand({
    collMod: "miColeccion",
    validator: { $jsonSchema: { bsonType: "object", required: ["x"] } },
    validationLevel: "off"
});
Cuándo usar cada nivel:

strict:
Es la opción más segura para asegurar la integridad de los datos. Úsalo si necesitas que todos los documentos cumplan siempre con las reglas de validación.

moderate:
Útil cuando estás migrando datos o aplicando validaciones de manera progresiva. Permite trabajar con documentos antiguos sin necesidad de modificarlos inmediatamente y cuando ya tenias un documento en la db y pones una nueva validacion que ese documento no cumple no lo contara cuando lo actualizes ya que estaba antes de la validacion.

off:
Ideal para casos en los que las reglas de validación están en desarrollo o en un entorno de pruebas donde no deseas que las validaciones interfieran con las operaciones de escritura.

Ejemplo completo:

db.runCommand({
    collMod: "miColeccion",
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["x", "y"],
            properties: {
                x: { bsonType: "string" },
                y: { bsonType: "string" }
            }
        }
    },
    validationLevel: "moderate"
});
Esto asegura que los documentos que ya están en la colección no se ven afectados, pero cualquier documento nuevo o actualizado deberá cumplir con las reglas de validación.


Hacer lo del validationAction
