

AGREGACIONES

((se esta trabajando sobre (se esta trabajando sobre profesionalPractitioner.json).json))

Las agregaciones son operaciones que procesan datos de una colección y devuelven resultados calculados o transformados. Estas operaciones son muy útiles para realizar análisis, filtrado y transformación de datos sin necesidad de mover los datos fuera de la base de datos.

El núcleo del sistema de agregaciones es el pipeline de agregación, que permite definir una serie de etapas que se aplican secuencialmente a los documentos de la colección. Cada etapa transforma los documentos y pasa el resultado a la siguiente etapa.

Cada vez que diga: "stage $operador" lo que significa que este es una etapa independiente dentro del pipeline de agregación
Cada vez que diga: "$operador" lo que significa que se usa dentro de un stage (como: $match, $group, $project)

stage $match: Filtra los documentos según una condición, similar a una consulta con find 
    -db.employee.aggregate([{$match: {maritalStatus: "S"}}])
    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}])


stage $group: Agrupa documentos por un campo específico y calcula valores agregados como sumas, promedios, conteos, etc, y poner el campo _id es obligatorio, los campos a partir del $group tendran que representarse como $campo

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: "$location.country"}}]) //filtra y agrupa por el pais, la salia parece decir que el _id son los paises pero es mentira, se puede cambiar

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: {country: "$location.country"}}}]) //le puedes agregar un nombre, en este caso tambien es  "country"

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: {country: "$location.country"}, countEmployee: {$count: {}}}}]) //cuenta los empleados segun el pais

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: {country: "$location.country"}, countEmployee: {$count: {}}, maximoquehepagado: {$max: "$yearlyPayment"}}}]) //el maximo de algo, lo contrario sera el $min


$sort: Se utiliza para ordenar los resultados de una agregación según uno o más campos. Puedes ordenar de manera ascendente o descendente, voy utilizando comandas del pasado que no tengan nada que ver que el tema de la linea para ver como se conbinan

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: {country: "$location.country"}, countEmployee: {$count: {}}, maximoquehepagado: {$max: "$yearlyPayment"}}}, {$sort: {countEmployee: -1, country: 1, maximoquehepagado: -1}}]) //veis como a partir del $sort vuelvo a utilizar los nombres que he creado en el $group?, se pueden reusar en la comanda

stage $count: se utiliza en una tubería de agregación para contar el número de documentos que pasan por las etapas anteriores y asignar ese valor a un campo llamado count (o como prefieras llamarlo)

    -db.employee.aggregate([{$match: {$and: [{maritalStatus: "S"}, {gender: "male"}]}}, {$group: {_id: {country: "$location.country"}, countEmployee: {$count: {}}, maximoquehepagado: {$max: "$yearlyPayment"}}}, {$sort: {countEmployee: -1, county: 1, maximoquehepagado: -1}}, {$count: "TotalDocumentos"}])
    [ { TotalDocumentos: 6 } ]

ACLARACION*

En la comanda de la linea 34 hay 2 $count, el primero es para contar el numero de trabajadores de "countEmployee", que porcierto parece magico no?, porque el cuenta sin haberle pasado ningun valor no?, Esto es porque el primer $count cuenta automáticamente la cantidad de documentos que llegan a esa etapa del pipeline, independientemente de los campos que tengan.

Cuando usas $count dentro de $group, no necesita un valor específico para contar. Simplemente incrementa un contador por cada documento que pertenece al grupo actual. Esto significa que no importa qué campos estén presentes en los documentos, $count simplemente cuenta cuántos hay en total para cada grupo.

Como el primer $count esta en la segunda etapa de pipeline, primero de haber pasado por el $match y el { country: "$location.country" } cuenta para cada documento que hay

El segundo $count cuenta los documentos, NO LOS EMPLEADOS, NO SALEN VALORES, AL PONER AL FINAL EL $count simplemente cuenta los documentos


stage $project: se utiliza para controlar qué campos aparecen en el resultado final y cómo se formatean. Básicamente, selecciona, excluye o modifica los campos del documento resultante después de que se hayan procesado las etapas anteriores del pipeline.

-db.employee.aggregate([{$match: {gender: "male"}}, {$group: {_id: {country: "$location.country"}, CountEmployee: {$count: {}}, maximopagado: {$max: "$yearlyPayment"}}}, {$sort: {maximopagado: -1}}, {$project: {country: "$_id.country", CountEmployee: 1,maximopagado: 1, _id: 0}}]) //el $project es basicamnete una projeccion, pero con el puedes agregar nuevos campos, modificarlos, excluirlo


$concat: se utiliza para unir (concatenar) cadenas de texto en un solo campo. Es útil cuando necesitas combinar varios valores, como juntar el nombre y apellido de una persona, o crear un formato personalizado para un campo.

    -db.employee.aggregate([{$match: {gender: "male"}}, {$group: {_id: {country: "$location.country"}, CountEmployee: {$count: {}}, maximopagado: {$max: "$yearlyPayment"}}}, {$sort: {maximopagado: -1}}, {$project: {country: "$_id.country", CountEmployee: 1,maximopagado: 1, _id: 0, concatenar: {$concat: ["Hey que pasa ", "$_id.country"]}}}]) //concatena el texto "Hey que pasa" con el pais que este

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ "$name.FirstName", " ",
    "$name.MiddleName", " ", "$name.LastName"] } } }] ) //si alguno de los campos es null no funcionara


$ifNull: se utiliza para manejar valores null o undefined dentro de una agregación. Su propósito es devolver un valor alternativo cuando el valor de un campo es null o no existe (es undefined).

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ "$name.FirstName", " ", {$ifNull: ["$name.MiddleName", ""]}, " ", "$name.LastName"]}, maritalStatus: 1, _id: 1}}]) //esto arregla el problema de la linea 55, ahora almenos aparecera el campo de "FirstName" y el de "LastName" sin que el "MiddleName" moleste porque es null


$replaceOne: se usa para reemplazar la primera coincidencia que encuentre dentro de una cadena. 
$replaceAll: es similar, pero en lugar de reemplazar solo la primera coincidencia, reemplaza todas las ocurrencias de un texto dentro de una cadena.

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: ["$name.FirstName", " ", { $ifNull: ["$name.MiddleName", ""] }, " ", "$name.LastName"] }, maritalStatus: 1, _id: 1 } }, { $project: { fullnombre: 1, maritalStatus: 1, _id: 1, name: { $replaceOne: { input: "$fullnombre", find: "  ", replacement: " " } } } }] ) //remplaza los "  "(espacios dobles) por un solo espacio, " "


$toLower: Convierte una cadena de texto a minúsculas
$toUpper: Convierte una cadena de texto a mayúsculas

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ {$toUpper: "$name.FirstName"}, " ", {$toLower: { $ifNull: ["$name.MiddleName", ""] }}, " ", {$toLower: "$name.LastName"}] }, maritalStatus: 1, _id: 1 } }, { $project: { fullnombre: 1, maritalStatus: 1, _id: 1, name: { $replaceOne: { input: "$fullnombre", find: "  ", replacement: " " } } } }] ) //el nombre esta en minuscula y los apellidos en mayusculas


$cond: permite crear expresiones condicionales dentro del pipeline de agregación, Es similar a un if-else en lenguajes de programación.

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $group: { _id: { country: "$location.country", maritalStatus: "$maritalStatus" }, countemployee: { $count: {} }, maximopagado: { $max: "$yearlyPayment" } } }, { $project: { country: "$_id.country", maritalStatus: "$_id.maritalStatus", countemployee: 1, _id: 0, concat: {$concat: ["Hola ", "$_id.country"]}, maritalStatus: {$cond: {if: {$eq: ["$_id.maritalStatus", "S"]}, then: "Single", else: "Married"}}}}]) //if "$_id.maritalStatus" $eq "S" then: "Single" else: "Married"(creo que se entiende)


$strLenCP: calcula la longitud de una cadena(incluido los espacios)

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ {$toUpper: "$name.FirstName"}, " ", {$toLower: { $ifNull: ["$name.MiddleName", ""] }}, " ", {$toLower: "$name.LastName"}] }, maritalStatus: 1, _id: 1 } }, { $project: { fullnombre: 1, maritalStatus: 1, _id: 1, fullnombre: { $replaceOne: { input: "$fullnombre", find: "  ", replacement: " " } }, conteo_nombre: {$strLenCP: "$fullnombre"}}}]) //conteo_nombre te dice el numero de caracteres que tiene un campo de tipo "string"



$indexOfCP: se utiliza para encontrar la posición de la primera aparición de una subcadena dentro de una cadena

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ {$toUpper: "$name.FirstName"}, " ", {$toLower: { $ifNull: ["$name.MiddleName", ""] }}, " ", {$toLower: "$name.LastName"}] }, maritalStatus: 1, _id: 1 } }, { $project: { fullnombre: 1, maritalStatus: 1, _id: 1, fullnombre: { $replaceOne: { input: "$fullnombre", find: "  ", replacement: " " } }, conteo_nombre: {$strLenCP: "$fullnombre"}, index: {$indexOfCP: ["$fullnombre", " "]}}}]) //muestra la posicion en la que se encuentra lo que busques


$substrCP: se utiliza para extraer una subcadena de una cadena, comenzando en una posición especificada y tomando una longitud determinada, el $indexOfCP y el $substrCP hacen muy buena convinacion

    -db.employee.aggregate([ { $match: { gender: "male" } }, { $project: { fullnombre: { $concat: [ {$toUpper: "$name.FirstName"}, " ", {$toLower: { $ifNull: ["$name.MiddleName", ""] }}, " ", {$toLower: "$name.LastName"}] }, maritalStatus: 1, _id: 1 } }, { $project: { fullnombre: 1, maritalStatus: 1, _id: 1, fullnombre: { $replaceOne: { input: "$fullnombre", find: "  ", replacement: " " } }, conteo_nombre: {$strLenCP: "$fullnombre"}, index: {$indexOfCP: ["$fullnombre", " "]}, firstname: {$substrCP: ["$fullnombre", 0, {$indexOfCP: ["$fullnombre", " "]}]}}}]) //vamos a cojer el primer nombre del campo "$fullnombre" desde la posicion 0, pero como no sabemos hasta cuando parar nos apoyamos del $indexOfCP que hemos hecho antes que para cuando nos encontremos con un " "



$switch: es una forma más compleja de realizar decisiones condicionales, similar a una declaración switch en otros lenguajes de programación

    -db.employee.aggregate([{ $project: { gender: 1, newgender: { $switch: { branches: [{ case: { $eq: ["$gender", "male"] }, then: "M" }, { case: { $eq: ["$gender", "female"] }, then: "F" }], default: "other" } } } }])


$convert: convertir valores de un tipo de dato a otro, es similar a la linea 811 en MongoDB-conceptos.txt, solo que ahora en agregaciones

    -db.employee.aggregate([{$project: {_id: 0, name: 1, coordinates_latitud: {$convert: {input: "$coordinates.latitude", to: "double"}}, coordinates_longitud: {$convert: {input: "$coordinates.longitude", to: "double"}}}}])

    -db.employee.aggregate([{$project: {_id: 0, name: 1, birthDate: {$convert: {input: "$date.birthDate", to: "date"}}}}])

    Tambien puedes comprovar si alguno de los valores da error o es null:
    -db.employee.aggregate([{$project: {_id: 0, name: 1, birthDate: {$convert: {input: "$date.birthDate", to: "date", onError: 0.0, onNull: 0.0}}}}]) //controla si hay valores nulos o errores


$toDataType: El conjunto de operadores $toString, $toInt, $toDouble, $toBool, etc..., tiene una sintaxis mas clara que el $convert pero no maneja errores ni nulos, es incluso mas similar a la linea 811 en MongoDB-conceptos.txt, solo que ahora en agregaciones

    -db.employee.aggregate([{$project: {name: 1, gender: 1, yearlyPayment: {$toString: "$yearlyPayment"}}}])


Datos Date


Hay muchos, pero muchos datos Date, para mas info: "https://www.mongodb.com/docs/manual/reference/operator/aggregation/" y buscar con "crt + f" esto: "Date Expression Operators" y hos saldran todos, vamos a hacer la prueba con 1



    -db.employee.aggregate([{$project: {name: 1, gender: 1, data: {$toDate: "$date.hireDate"}}}, {$group: {_id: {year: {$year: "$data"}}, totalemployee: {$count: {}}}}, {$sort: {year: -1}}]) //cuenta los empleados contratados en cada respectivo año


AHORA TOCA VER AGREGACIONES EN ARRAYS

$push: se usa dentro de $group para agrupar documentos y almacenar valores en un array. Permite crear listas de elementos dentro de cada grupo, (se esta trabajando sobre profesionalPractitioner.json)

    -db.employee.aggregate([{$group: {_id: {age: "$age"}, allLanguajes: {$push: "$language"}}}])

stage $unwind: descompone un array en múltiples documentos individuales. Cada elemento del array se convierte en un nuevo documento.

    -db.employee.aggregate([{$unwind: "$language"}]) //descompone el array en documentos individuales

    [
        {
            "_id": ObjectId("679a0fbe97cd379c879c36f9"),
            "name": "Juan",
            "language": "JavaScript",
            "age": 30,
            "qualification": [
            { "difficulty": 9, "score": 16.9 },
            { "difficulty": 4, "score": 15.9 },
            { "difficulty": 2, "score": 19.5 }
            ]
        },
        {
            "_id": ObjectId("679a0fbe97cd379c879c36f9"),
            "name": "Juan",
            "language": "PHP",
            "age": 30,
            "qualification": [
            { "difficulty": 9, "score": 16.9 },
            { "difficulty": 4, "score": 15.9 },
            { "difficulty": 2, "score": 19.5 }
            ]
        }
    ]
    etc...

Pero podemos separarlo para luego volver a juntarlos

    -db.employee.aggregate([{$unwind: "$language"}, {$group: {_id: {age: "$age"}, allLanguajes: {$push: "$language"}}}]) //ahora estan todas en una misma array y no en 2 separadas como en la linea 136  


$addToSet: para agregar valores a un array sin duplicados. Es similar a $push, pero mientras que $push agrega un valor a un array incluso si ya está presente, $addToSet asegura que solo se agregue si el valor no está ya en el array, (el $addToSet de siempre)  

    -db.employee.aggregate([{$unwind: "$language"}, {$group: {_id: {age: "$age"}, allLanguajes: {$addToSet: "$language"}}}]) //Python ya no esta repetido


$filter: filtrar elementos dentro de un array según una condición

    -db.employee.aggregate([{$project: {name: 1, language: {$filter: {input: "$qualification.score",
    as: "sc", cond: {$gt: ["$$sc", 19]}}}}}])

*Aclaracion

La razón por la que $filter usa "cond" en lugar de "$cond" es porque "cond" es un parámetro dentro del operador $filter, mientras que "$cond" es un operador de expresión condicional que se usa para evaluar condiciones en una agregación.

*Aclaracion2

El "$$sc" usa 2 "$$" al ser un alias, y $filter necessita el alias


stage $set: agregar nuevos campos o modificar los existentes, es parecido al $project pero en este no hace falta que en cada stage que uses $project vayas repitiendo los campo

    -db.employee.aggregate([{$set: {departamento: "este", totalscore: {$sum: "$qualification.score"}, media: {$round: [{$avg: "$qualification.score"}, 2]}}}]) //de paso el $round redonde segun el valor que le pongas, en mi caso 2, 2 decimales

stage $unset: eliminar uno o más campos de los documentos durante una operación de agregación

    -db.employee.aggregate([{$unset: ["age", "language", "qualification.difficulty"]}]) //si solo quieres eliminar 1, quitale las []