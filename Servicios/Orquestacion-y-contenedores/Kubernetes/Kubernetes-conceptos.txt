
Kubernetes es


Ha kubernetes tambiÃ©n se lo suele llamar k8s por abreviacion debido a que su nombre es muy largo, el significado de esta abreviatura es que entre la k y la s hay 8 letras: k u(1)b(2)e(3)r(4)n(5)e(6)t(7)e(8) s

**ACLARACIÃ“N 

Kubernetes no es otro sistema de contenedores como Docker, es una plataforma que se encarga de administrar esos contenedores, ya vengan de Docker, Podman o cualquier otro que use containerd por debajo.


Kubernetes se basa en una arquitectura de nodos master (control plane) y workers. El master toma decisiones y administra el estado del clÃºster, mientras los workers ejecutan los contenedores. El control plane orquesta y supervisa, y los workers hacen el trabajo real corriendo las aplicaciones.

Los nodos master son donde se deciden los contenedore y donde ponerlos, los workes son solo nodos que tienen los procesos que se han declarado en los masters, los masters tambien pueden tener contenedores dentro y un worker no puede declarar contenedor para el cluster

Es importante tener en cunta que solo los nodos masters tienen estos componentes: KubernetesAPI, Kube-Scheduler, Kube-Controller, Etcd
Los nodos workes tienen: kubelet, kube-proxy, Container runtime

**ACLARACION

Realmete los nodos masters aparte de los que ya he dicho tienen tambien los componentes que usan los workers, pero los nodos masters no suelen usarlos ya que esos nodos solo se reservan a declaran contenedores y pods y no tanto para trabajar
Igual que Docker Swarm, al fin y alcabo estamos viendo otro orquestador de contenedores


**La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes**
La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes

Kubernetes API - es la interfaz central y RESTful de Kubernetes que permite interactuar con todos los recursos del clÃºster como pods, deployments o servicios funcionando como el nÃºcleo del sistema ya que todo â€”desde herramientas como kubectl hasta controladores internosâ€” se comunica con ella para crear, leer, actualizar o eliminar objetos en el clÃºster(todo comando escrito por linea de comandos mediante kubectl sera enviado a la API de kubernetes)

Kube-Scheduler - es el componente del plano de control de Kubernetes responsable de decidir en quÃ© nodo se ejecutarÃ¡ cada pod pendiente segÃºn varios factores como recursos disponibles, afinidades, restricciones, taints y tolerations, garantizando que los pods se ubiquen de forma eficiente y acorde a las necesidades declaradas por el usuario y el estado del clÃºster

Kube-Scheduler es el componente de Kubernetes que decide en quÃ© nodo del clÃºster se ejecutarÃ¡ cada nuevo pod pendiente, basÃ¡ndose en criterios como uso de recursos, afinidades, restricciones y mÃ¡s; por ejemplo, si hay dos nodos y cada uno ya tiene dos contenedores, el scheduler elegirÃ¡ automÃ¡ticamente el nodo mÃ¡s adecuado para desplegar un nuevo contenedor, a menos que el usuario especifique lo contrario mediante reglas o configuraciones.

Kube-Controller - es el componente que ejecuta los controladores de Kubernetes, los cuales monitorean el estado del clÃºster y trabajan para que el estado actual coincida con el estado deseado, gestionando tareas como replicar pods, manejar nodos caÃ­dos, y administrar recursos, asegurando que todo funcione correctamente y de forma automÃ¡tica.

el Kube-Controller agrupa varios controladores que se encargan de tareas especÃ­ficas dentro del clÃºster. Los principales son:

Node Controller: supervisa el estado de los nodos y actÃºa si detecta que un nodo estÃ¡ caÃ­do o no responde.

Replication Controller: garantiza que un nÃºmero especificado de rÃ©plicas de un pod estÃ©n corriendo siempre, creando o eliminando pods segÃºn sea necesario.

Endpoints Controller: conecta servicios con pods para asegurar la correcta comunicaciÃ³n.

Service Account & Token Controller: maneja cuentas de servicio y tokens para autenticaciÃ³n dentro del clÃºster.

etcd - es la base de datos distribuida clave-valor que utiliza Kubernetes para almacenar toda la informaciÃ³n del clÃºster, incluyendo el estado de los pods, configuraciones, secretos y cualquier recurso; actÃºa como la fuente de verdad del sistema, permitiendo que los componentes del plano de control lean y escriban datos para mantener la coherencia y el funcionamiento del clÃºster.

Kubelet - es el agente que corre en cada nodo del clÃºster y se encarga de garantizar que los contenedores se ejecuten correctamente segÃºn las definiciones de los pods que recibe del plano de control; supervisa el estado de los contenedores, informa al API Server y reinicia los pods si es necesario para mantener el estado deseado en ese nodo.

Kube-Proxy - es el componente de red que corre en cada nodo de Kubernetes y se encarga de enrutar el trÃ¡fico de red hacia los pods apropiados, gestionando las reglas de red necesarias para exponer servicios dentro del clÃºster y permitiendo la comunicaciÃ³n entre pods, nodos y servicios, ya sea mediante reglas iptables o eBPF segÃºn la configuraciÃ³n del entorno.

ContainerRuntime - BÃ¡sicamente el sistema de contenedores que tengas instalado, ya sea: docker, cryo, podman, etc...


VALE, una vez que nos sabemos la teoria de k8s, vamos a tocar algunos comandos, pera antes la instalacion:

Vamos a usar minikube que es una herramienta que permite crear y ejecutar un clÃºster de Kubernetes local en una sola mÃ¡quina, ideal para desarrollo, pruebas y aprendizaje, ya que simula un entorno Kubernetes completo con un solo nodo (o mÃ¡s si se configura), facilitando la experimentaciÃ³n sin necesidad de usar infraestructura en la nube.

TENEMOS QUE TENER DOCKER YA instalado

Vamos a instalar 2 herramienta: kubectl y minikube

kubectl: kubectl es la herramienta de lÃ­nea de comandos que se usa para comunicarse con un clÃºster de Kubernetes.

minikube: minikube es una herramienta que crea y ejecuta un clÃºster de Kubernetes en tu propia mÃ¡quina, ideal para desarrollo y pruebas.


INSTALAR kubectl

    -curl -LO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

Verifica:

    -kubectl version --client


INSTALAR minikube

    -curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube

Verifica:

    -minikube version



Y por ultimo usaremos como backend de k8s el propio docker

    -minikube start --driver=docker
    ğŸ˜„  minikube v1.36.0 en Ubuntu 22.04 (vbox/amd64)
    âœ¨  Using the docker driver based on user configuration
    ğŸ“Œ  Using Docker driver with root privileges
    ğŸ‘  Starting "minikube" primary control-plane node in "minikube" cluster
    ğŸšœ  Pulling base image v0.0.47 ...
    ğŸ’¾  Descargando Kubernetes v1.33.1 ...
        > preloaded-images-k8s-v18-v1...:  347.04 MiB / 347.04 MiB  100.00% 21.80 M
        > gcr.io/k8s-minikube/kicbase...:  501.83 MiB / 502.26 MiB  99.91% 12.83 Mi
    ğŸ”¥  Creating docker container (CPUs=2, Memory=2200MB) ...
    ğŸ³  Preparando Kubernetes v1.33.1 en Docker 28.1.1...
        â–ª Generando certificados y llaves
        â–ª Iniciando plano de control
        â–ª Configurando reglas RBAC...
    ğŸ”—  Configurando CNI bridge CNI ...
    ğŸ”  Verifying Kubernetes components...
        â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
    ğŸŒŸ  Complementos habilitados: storage-provisioner, default-storageclass
    ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default

Si hubieras puesto la siqguiente linea te hubiera cojido docker tambien, porque es el por defecto, tambien se puede hacer con virtualbox en caso de que se tenga instalado:

    -minikube start --driver=none/virtualbox


COMANDOS BÃSICOS EN Minikube

    
    -minikube status (muestra info de si las cosas van bien)
    -minikube stop (detiene el cluster)
    -minikube start (inicia el cluster)
    -minikube delete (elimina por completo el cluster, lo puedes volver a tener tu cluster con: minikube start, sino pones el --driver=docker lo hace solo al parecer o el que ya tenias?, no se)
