
Kubernetes es


Ha kubernetes tambi√©n se lo suele llamar k8s por abreviacion debido a que su nombre es muy largo, el significado de esta abreviatura es que entre la k y la s hay 8 letras: k u(1)b(2)e(3)r(4)n(5)e(6)t(7)e(8) s

**ACLARACI√ìN 

Kubernetes no es otro sistema de contenedores como Docker, es una plataforma que se encarga de administrar esos contenedores, ya vengan de Docker, Podman o cualquier otro que use containerd por debajo.


Kubernetes se basa en una arquitectura de nodos master (control plane) y workers. El master toma decisiones y administra el estado del cl√∫ster, mientras los workers ejecutan los contenedores. El control plane orquesta y supervisa, y los workers hacen el trabajo real corriendo las aplicaciones.

Los nodos master son donde se deciden los contenedore y donde ponerlos, los workes son solo nodos que tienen los procesos que se han declarado en los masters, los masters tambien pueden tener contenedores dentro y un worker no puede declarar contenedor para el cluster

Es importante tener en cunta que solo los nodos masters tienen estos componentes: KubernetesAPI, Kube-Scheduler, Kube-Controller, Etcd
Los nodos workes tienen: kubelet, kube-proxy, Container runtime

**ACLARACION

Realmete los nodos masters aparte de los que ya he dicho tienen tambien los componentes que usan los workers, pero los nodos masters no suelen usarlos ya que esos nodos solo se reservan a declaran contenedores y pods y no tanto para trabajar
Igual que Docker Swarm, al fin y alcabo estamos viendo otro orquestador de contenedores


**La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes**
La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes

Kubernetes API - es la interfaz central y RESTful de Kubernetes que permite interactuar con todos los recursos del cl√∫ster como pods, deployments o servicios funcionando como el n√∫cleo del sistema ya que todo ‚Äîdesde herramientas como kubectl hasta controladores internos‚Äî se comunica con ella para crear, leer, actualizar o eliminar objetos en el cl√∫ster(todo comando escrito por linea de comandos mediante kubectl sera enviado a la API de kubernetes)

Kube-Scheduler - es el componente del plano de control de Kubernetes responsable de decidir en qu√© nodo se ejecutar√° cada pod pendiente seg√∫n varios factores como recursos disponibles, afinidades, restricciones, taints y tolerations, garantizando que los pods se ubiquen de forma eficiente y acorde a las necesidades declaradas por el usuario y el estado del cl√∫ster

Kube-Scheduler es el componente de Kubernetes que decide en qu√© nodo del cl√∫ster se ejecutar√° cada nuevo pod pendiente, bas√°ndose en criterios como uso de recursos, afinidades, restricciones y m√°s; por ejemplo, si hay dos nodos y cada uno ya tiene dos contenedores, el scheduler elegir√° autom√°ticamente el nodo m√°s adecuado para desplegar un nuevo contenedor, a menos que el usuario especifique lo contrario mediante reglas o configuraciones.

Kube-Controller - es el componente que ejecuta los controladores de Kubernetes, los cuales monitorean el estado del cl√∫ster y trabajan para que el estado actual coincida con el estado deseado, gestionando tareas como replicar pods, manejar nodos ca√≠dos, y administrar recursos, asegurando que todo funcione correctamente y de forma autom√°tica.

el Kube-Controller agrupa varios controladores que se encargan de tareas espec√≠ficas dentro del cl√∫ster. Los principales son:

Node Controller: supervisa el estado de los nodos y act√∫a si detecta que un nodo est√° ca√≠do o no responde.

Replication Controller: garantiza que un n√∫mero especificado de r√©plicas de un pod est√©n corriendo siempre, creando o eliminando pods seg√∫n sea necesario.

Endpoints Controller: conecta servicios con pods para asegurar la correcta comunicaci√≥n.

Service Account & Token Controller: maneja cuentas de servicio y tokens para autenticaci√≥n dentro del cl√∫ster.

etcd - es la base de datos distribuida clave-valor que utiliza Kubernetes para almacenar toda la informaci√≥n del cl√∫ster, incluyendo el estado de los pods, configuraciones, secretos y cualquier recurso; act√∫a como la fuente de verdad del sistema, permitiendo que los componentes del plano de control lean y escriban datos para mantener la coherencia y el funcionamiento del cl√∫ster.

Kubelet - es el agente que corre en cada nodo del cl√∫ster y se encarga de garantizar que los contenedores se ejecuten correctamente seg√∫n las definiciones de los pods que recibe del plano de control; supervisa el estado de los contenedores, informa al API Server y reinicia los pods si es necesario para mantener el estado deseado en ese nodo.

Kube-Proxy - es el componente de red que corre en cada nodo de Kubernetes y se encarga de enrutar el tr√°fico de red hacia los pods apropiados, gestionando las reglas de red necesarias para exponer servicios dentro del cl√∫ster y permitiendo la comunicaci√≥n entre pods, nodos y servicios, ya sea mediante reglas iptables o eBPF seg√∫n la configuraci√≥n del entorno.

ContainerRuntime - B√°sicamente el sistema de contenedores que tengas instalado, ya sea: docker, cryo, podman, etc...


VALE, una vez que nos sabemos la teoria de k8s, vamos a tocar algunos comandos, pera antes la instalacion:

Vamos a usar minikube que es una herramienta que permite crear y ejecutar un cl√∫ster de Kubernetes local en una sola m√°quina, ideal para desarrollo, pruebas y aprendizaje, ya que simula un entorno Kubernetes completo con un solo nodo (o m√°s si se configura), facilitando la experimentaci√≥n sin necesidad de usar infraestructura en la nube.

TENEMOS QUE TENER DOCKER YA instalado

Vamos a instalar 2 herramienta: kubectl y minikube

kubectl: kubectl es la herramienta de l√≠nea de comandos que se usa para comunicarse con un cl√∫ster de Kubernetes.

minikube: minikube es una herramienta que crea y ejecuta un cl√∫ster de Kubernetes en tu propia m√°quina, ideal para desarrollo y pruebas.


INSTALAR kubectl

    -curl -LO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

Verifica:

    -kubectl version --client


INSTALAR minikube

    -curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube

Verifica:

    -minikube version



Y por ultimo usaremos como backend de k8s el propio docker

    -minikube start --driver=docker
    üòÑ  minikube v1.36.0 en Ubuntu 22.04 (vbox/amd64)
    ‚ú®  Using the docker driver based on user configuration
    üìå  Using Docker driver with root privileges
    üëç  Starting "minikube" primary control-plane node in "minikube" cluster
    üöú  Pulling base image v0.0.47 ...
    üíæ  Descargando Kubernetes v1.33.1 ...
        > preloaded-images-k8s-v18-v1...:  347.04 MiB / 347.04 MiB  100.00% 21.80 M
        > gcr.io/k8s-minikube/kicbase...:  501.83 MiB / 502.26 MiB  99.91% 12.83 Mi
    üî•  Creating docker container (CPUs=2, Memory=2200MB) ...
    üê≥  Preparando Kubernetes v1.33.1 en Docker 28.1.1...
        ‚ñ™ Generando certificados y llaves
        ‚ñ™ Iniciando plano de control
        ‚ñ™ Configurando reglas RBAC...
    üîó  Configurando CNI bridge CNI ...
    üîé  Verifying Kubernetes components...
        ‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
    üåü  Complementos habilitados: storage-provisioner, default-storageclass
    üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default

Si hubieras puesto la siqguiente linea te hubiera cojido docker tambien, porque es el por defecto, tambien se puede hacer con virtualbox en caso de que se tenga instalado:

    -minikube start --driver=none/virtualbox


COMANDOS B√ÅSICOS EN Minikube

    
    -minikube status (muestra info de si las cosas van bien)
    -minikube stop (detiene el cluster)
    -minikube start (inicia el cluster)
    -minikube delete (elimina por completo el cluster, lo puedes volver a tener tu cluster con: minikube start, sino pones el --driver=docker lo hace solo al parecer o el que ya tenias?, no se)


Una vez tenemos ya el cluster podemos empezar ha aprender ha hecer la unidad mas peque√±a que se puede hacer en k82, un pod

**ACLARACI√ìN

Si apagas la maquina virtual con el cluster corriendo, luego cuando inicies la maquina de nuevo ese cluster no estara, habra que encenderlo, almenos los pods se quedan

PODS:

Lo mas normal a utilizar es 1 pod por contenedor

Crear un pod
    -kubectl run podtest --image=nginx:alpine 
    
    Sintaxis
    kubectl run <nombre del pod que quieras> --image=<imagen>
    pod/podtest created

Si intentas crear un pod con una imagen que no existe igualmente te dira que la hara:
    -kubectl run podtest --image=enjinx

Pero al momento de ver los pods:

podtest1     0/1     ErrImagePull   0             3s


Ver tus pods
    -kubectl get pods 


Por si tienes un monton de pos puedes ver uno especifico con:

    -kubectl get pods nombrepod


NAME         READY   STATUS    RESTARTS      AGE
podapache2   1/1     Running   0             3m47s
podtest      1/1     Running   1 (25h ago)   25h

Aqui por ejemplo primero cree el pod: podtest ayer digamos, apague la maquina y al dia siguiente la encendi, puse en marcha el cluster y poreso tiene 1 restart, el podapache2 lo he hecho hoy y no he apago la maquina, si lo hiciera tendria 1 restart y el otro 2



Ver descripcion de tus pods(como el inspect en docker)
    -kubectl describe pod nombrepod

Ejemplo, vamos a describir el pod que nos dio un error en la imagen:

    -kubectl describe pod podtest1

Name:             podtest1
Namespace:        default
Priority:         0
Service Account:  default
Node:             minikube/192.168.49.2
Start Time:       Thu, 24 Jul 2025 11:36:21 +0000
Labels:           run=podtest1
Annotations:      <none>
Status:           Pending
IP:               10.244.0.8
IPs:
  IP:  10.244.0.8
Containers:
  podtest1:
    Container ID:
    Image:          enjinx
    Image ID:
    Port:           <none>
    Host Port:      <none>
    State:          Waiting
      Reason:       ImagePullBackOff
    Ready:          False
    Restart Count:  0
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-2glkq (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True
  Initialized                 True
  Ready                       False
  ContainersReady             False
  PodScheduled                True
Volumes:
  kube-api-access-2glkq:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    Optional:                false
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type     Reason     Age                  From               Message
  ----     ------     ----                 ----               -------
  Normal   Scheduled  3m46s                default-scheduler  Successfully assigned default/podtest1 to minikube
  Normal   Pulling    45s (x5 over 3m46s)  kubelet            Pulling image "enjinx"
  Warning  Failed     43s (x5 over 3m44s)  kubelet            Failed to pull image "enjinx": Error response from daemon: pull access denied for enjinx, repository does not exist or may require 'docker login': denied: requested access to the resource is denied
  Warning  Failed     43s (x5 over 3m44s)  kubelet            Error: ErrImagePull
  Normal   BackOff    6s (x13 over 3m44s)  kubelet            Back-off pulling image "enjinx"
  Warning  Failed     6s (x13 over 3m44s)  kubelet            Error: ImagePullBackOff

    

Lo que se sule mirar si algo falla son los eventos, lo demas de arriba es decripcion del pod en si


Eliminar pods:
    -kubectl delete pod podtest1


Ver todos los comandos y abrebiaciones del cliente de la terminal de k8s:

    -kubectl api-resources

Con esto por ejemplo nos enteramos que no hace falta que escribamos la palabra "pod" tal cual, tambien la podemos escribir asi: "po", entonces se puede hacer esto:

    -kubectl get po

Y funcionara    


Obtener el yaml de un pod:

    -kubectl get pod nombrepod -o yaml

Y te da un yaml larguissimo que no voy a poner    
