
Kubernetes es


Ha kubernetes también se lo suele llamar k8s por abreviacion debido a que su nombre es muy largo, el significado de esta abreviatura es que entre la k y la s hay 8 letras: k u(1)b(2)e(3)r(4)n(5)e(6)t(7)e(8) s

**ACLARACIÓN 

Kubernetes no es otro sistema de contenedores como Docker, es una plataforma que se encarga de administrar esos contenedores, ya vengan de Docker, Podman o cualquier otro que use containerd por debajo.


Kubernetes se basa en una arquitectura de nodos master (control plane) y workers. El master toma decisiones y administra el estado del clúster, mientras los workers ejecutan los contenedores. El control plane orquesta y supervisa, y los workers hacen el trabajo real corriendo las aplicaciones.

Los nodos master son donde se deciden los contenedore y donde ponerlos, los workes son solo nodos que tienen los procesos que se han declarado en los masters, los masters tambien pueden tener contenedores dentro y un worker no puede declarar contenedor para el cluster

Es importante tener en cunta que solo los nodos masters tienen estos componentes: KubernetesAPI, Kube-Scheduler, Kube-Controller, Etcd
Los nodos workes tienen: kubelet, kube-proxy, Container runtime

**ACLARACION

Realmete los nodos masters aparte de los que ya he dicho tienen tambien los componentes que usan los workers, pero los nodos masters no suelen usarlos ya que esos nodos solo se reservan a declaran contenedores y pods y no tanto para trabajar
Igual que Docker Swarm, al fin y alcabo estamos viendo otro orquestador de contenedores


**La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes**
La arquitectura interna de Kubernetes o los componentes fundamentales de Kubernetes

Kubernetes API - es la interfaz central y RESTful de Kubernetes que permite interactuar con todos los recursos del clúster como pods, deployments o servicios funcionando como el núcleo del sistema ya que todo —desde herramientas como kubectl hasta controladores internos— se comunica con ella para crear, leer, actualizar o eliminar objetos en el clúster(todo comando escrito por linea de comandos mediante kubectl sera enviado a la API de kubernetes)

Kube-Scheduler - es el componente del plano de control de Kubernetes responsable de decidir en qué nodo se ejecutará cada pod pendiente según varios factores como recursos disponibles, afinidades, restricciones, taints y tolerations, garantizando que los pods se ubiquen de forma eficiente y acorde a las necesidades declaradas por el usuario y el estado del clúster

Kube-Scheduler es el componente de Kubernetes que decide en qué nodo del clúster se ejecutará cada nuevo pod pendiente, basándose en criterios como uso de recursos, afinidades, restricciones y más; por ejemplo, si hay dos nodos y cada uno ya tiene dos contenedores, el scheduler elegirá automáticamente el nodo más adecuado para desplegar un nuevo contenedor, a menos que el usuario especifique lo contrario mediante reglas o configuraciones.

Kube-Controller - es el componente que ejecuta los controladores de Kubernetes, los cuales monitorean el estado del clúster y trabajan para que el estado actual coincida con el estado deseado, gestionando tareas como replicar pods, manejar nodos caídos, y administrar recursos, asegurando que todo funcione correctamente y de forma automática.

el Kube-Controller agrupa varios controladores que se encargan de tareas específicas dentro del clúster. Los principales son:

Node Controller: supervisa el estado de los nodos y actúa si detecta que un nodo está caído o no responde.

Replication Controller: garantiza que un número especificado de réplicas de un pod estén corriendo siempre, creando o eliminando pods según sea necesario.

Endpoints Controller: conecta servicios con pods para asegurar la correcta comunicación.

Service Account & Token Controller: maneja cuentas de servicio y tokens para autenticación dentro del clúster.

etcd - es la base de datos distribuida clave-valor que utiliza Kubernetes para almacenar toda la información del clúster, incluyendo el estado de los pods, configuraciones, secretos y cualquier recurso; actúa como la fuente de verdad del sistema, permitiendo que los componentes del plano de control lean y escriban datos para mantener la coherencia y el funcionamiento del clúster.

Kubelet - es el agente que corre en cada nodo del clúster y se encarga de garantizar que los contenedores se ejecuten correctamente según las definiciones de los pods que recibe del plano de control; supervisa el estado de los contenedores, informa al API Server y reinicia los pods si es necesario para mantener el estado deseado en ese nodo.

Kube-Proxy - es el componente de red que corre en cada nodo de Kubernetes y se encarga de enrutar el tráfico de red hacia los pods apropiados, gestionando las reglas de red necesarias para exponer servicios dentro del clúster y permitiendo la comunicación entre pods, nodos y servicios, ya sea mediante reglas iptables o eBPF según la configuración del entorno.

ContainerRuntime - Básicamente el sistema de contenedores que tengas instalado, ya sea: docker, cryo, podman, etc...


VALE, una vez que nos sabemos la teoria de k8s, vamos a tocar algunos comandos, pera antes la instalacion:

Vamos a usar minikube que es una herramienta que permite crear y ejecutar un clúster de Kubernetes local en una sola máquina, ideal para desarrollo, pruebas y aprendizaje, ya que simula un entorno Kubernetes completo con un solo nodo (o más si se configura), facilitando la experimentación sin necesidad de usar infraestructura en la nube.

TENEMOS QUE TENER DOCKER YA instalado

Vamos a instalar 2 herramienta: kubectl y minikube

kubectl: kubectl es la herramienta de línea de comandos que se usa para comunicarse con un clúster de Kubernetes.

minikube: minikube es una herramienta que crea y ejecuta un clúster de Kubernetes en tu propia máquina, ideal para desarrollo y pruebas.


INSTALAR kubectl

    -curl -LO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

Verifica:

    -kubectl version --client


INSTALAR minikube

    -curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube

Verifica:

    -minikube version



Y por ultimo usaremos como backend de k8s el propio docker

    -minikube start --driver=docker
    😄  minikube v1.36.0 en Ubuntu 22.04 (vbox/amd64)
    ✨  Using the docker driver based on user configuration
    📌  Using Docker driver with root privileges
    👍  Starting "minikube" primary control-plane node in "minikube" cluster
    🚜  Pulling base image v0.0.47 ...
    💾  Descargando Kubernetes v1.33.1 ...
        > preloaded-images-k8s-v18-v1...:  347.04 MiB / 347.04 MiB  100.00% 21.80 M
        > gcr.io/k8s-minikube/kicbase...:  501.83 MiB / 502.26 MiB  99.91% 12.83 Mi
    🔥  Creating docker container (CPUs=2, Memory=2200MB) ...
    🐳  Preparando Kubernetes v1.33.1 en Docker 28.1.1...
        ▪ Generando certificados y llaves
        ▪ Iniciando plano de control
        ▪ Configurando reglas RBAC...
    🔗  Configurando CNI bridge CNI ...
    🔎  Verifying Kubernetes components...
        ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
    🌟  Complementos habilitados: storage-provisioner, default-storageclass
    🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default

Si hubieras puesto la siqguiente linea te hubiera cojido docker tambien, porque es el por defecto, tambien se puede hacer con virtualbox en caso de que se tenga instalado:

    -minikube start --driver=none/virtualbox


COMANDOS BÁSICOS EN Minikube

    
    -minikube status (muestra info de si las cosas van bien)
    -minikube stop (detiene el cluster)
    -minikube start (inicia el cluster)
    -minikube delete (elimina por completo el cluster, lo puedes volver a tener tu cluster con: minikube start, sino pones el --driver=docker lo hace solo al parecer o el que ya tenias?, no se)
